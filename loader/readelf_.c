char ** argv;
#ifndef __SHARED__
#warning recompile this with the flag -D__SHARED__ to enable compiling this as a shared library

int
readelf_(const char * filename);
int main() {
    readelf_(argv[0]);
}
#endif

#ifdef __SHARED__
void * lookup_symbol_by_name_(const char * lib, const char * name);
// for C++ symbol name demangling should libirty become incompatible
// http://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling
// https://itanium-cxx-abi.github.io/cxx-abi/gcc-cxxabi.h
// https://github.com/xaxxon/xl/blob/master/include/xl/demangle.h
// gdb and c++filt use demangler provided by libiberty

// allow for demangling of C++ symbols, link with -liberty
#include <libiberty/libiberty.h>
#include <libiberty/demangle.h>
#include <libiberty/safe-ctype.h>
int flags = DMGL_PARAMS | DMGL_ANSI | DMGL_VERBOSE;
int strip_underscore = 0;
char * demangle_it (char *mangled_name)
{
  char *result;
  unsigned int skip_first = 0;

  /* _ and $ are sometimes found at the start of function names
     in assembler sources in order to distinguish them from other
     names (eg register names).  So skip them here.  */
  if (mangled_name[0] == '.' || mangled_name[0] == '$')
    ++skip_first;
  if (strip_underscore && mangled_name[skip_first] == '_')
    ++skip_first;

  result = cplus_demangle (mangled_name + skip_first, flags);
//   bytecmp(mangled_name, mangled_name);
//   printf("\n\nmangled_name[%d] = %c , mangled_name[%d] = %c\n\n", strlen(mangled_name)-2, strlen(mangled_name)-1, mangled_name[strlen(mangled_name)-2], mangled_name[strlen(mangled_name)-1]);
//     if ( mangled_name[-2] == '(' && mangled_name[-1] == ')')
//         mangled_name[-2] = '\0';
  if (result == NULL) return mangled_name;
  else if (mangled_name[0] == '.') return strjoin_(".", result); else return result;
}

char * __print_quoted_string__(const char *str, unsigned int size, const unsigned int style, const char * return_type);
#define _GNU_SOURCE
#define __USE_GNU
// ELF Spec FULL:  http://refspecs.linuxbase.org/elf/elf.pdf
#include <link.h>
size_t align;
ElfW(Addr) base_address = 0x00000000;
ElfW(Addr) mappingb_end = 0x00000000;
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

//sig handling
#include <signal.h>
#include <ucontext.h>
#include <setjmp.h>
#include <errno.h>

jmp_buf restore_point;
jmp_buf restore_pointb;
struct sigaction sa, sab;
void Handlerb(int sig, siginfo_t *si, ucontext_t *unused)
{
//     printf("received signal (%d)\n", sig);
    if (sig == SIGSEGV)
    {
        printf("\r    NOTICE\n");
        void * h_ = &Handlerb;
        printf("    received SegFault (%d)\n", sig);
        printf("    addr:   %p\n", si->si_addr);
        printf("    arch:   %d\n", si->si_arch);
        printf("    signo:  %d\n", si->si_signo);
        printf("    errno:  %d\n", si->si_errno);
        printf("    code:   %d (If this is less than or equal to 0, then the signal was generated by a process)\n", si->si_code);
        printf("    pid:    %d\n", (pid_t) si->si_pid);
        printf("    uid:    %d\n", (uid_t) si->si_uid);
        printf("    value:  %d\n", (sigval_t) si->si_value);
        printf("    status: %d\n", si->si_status);
        printf("    aquiring ucontext_t\n");
        getcontext(unused);
        signal(SIGSEGV, h_);
        longjmp(restore_pointb, SIGSEGV);
    }
}

void
init_handlerb() {
    sab.sa_flags = SA_SIGINFO|SA_NODEFER;
    sigemptyset(&sab.sa_mask);
    sab.sa_sigaction = Handlerb;
    if (sigaction(SIGSEGV, &sab, NULL) == -1) {
        perror("failed to set handler");
        pause();
    }
}

void Handler(int sig, siginfo_t *si, ucontext_t *context)
{
//     init_handlerb();

// dont print anything, silently skip

//     printf("                                                                                                                        received signal (%d)\n", sig);
    if (sig == SIGSEGV)
    {
//         printf("NOTICE\n");
        void * h = &Handler;
//         printf("received SegFault (%d)\n", sig);
//         printf("addr:   %p\n", si->si_addr);
//         int fault_code = setjmp(restore_pointb);
//         if (fault_code == 0) printf("arch:   %d\n", si->si_arch);
//         else  printf("arch:   NULL (recovered from a fault, code = %d)\n", fault_code);
//         printf("signo:  %d\n", si->si_signo);
//         printf("errno:  %d\n", si->si_errno);
//         printf("code:   %d (If this is less than or equal to 0, then the signal was generated by a process)\n", si->si_code);
//         printf("pid:    %d\n", (pid_t) si->si_pid);
//         printf("uid:    %d\n", (uid_t) si->si_uid);
//         printf("value:  %d\n", (sigval_t) si->si_value);
//         printf("status: %d\n", si->si_status);
//         printf("aquiring ucontext_t\n");
//         printf("Address of crash:          %x\n",context->uc_mcontext.gregs[REG_RIP]);
//  RAX  0xbc748
//  RBX  0x2
//  RCX  0x40bbba (__libc_sigaction+266) ◂— cmp    rax, -0x1000 /* 'H=' */
//  RDX  0x86d3373220279bca
//  RDI  0x6bbe00 (restore_point) ◂— 0x2
//  RSI  0x0
//  R8   0x0
//  R9   0x33
//  R10  0x8
//  R11  0x246
//  R12  0x0
//  R13  0x6ba340 (_dl_main_map) ◂— 0
//  R14  0x6b9018 (_GLOBAL_OFFSET_TABLE_+24) —▸ 0x432240 (__strcpy_ssse3) ◂— mov    rcx, rsi
//  R15  0x0
//  RBP  0x7fffffffe0b0 —▸ 0x7fffffffe0f0 —▸ 0x4012d9 (callback) ◂— push   rbp
//  RSP  0x7fffffffe090 —▸ 0x7fffffffe1d0 —▸ 0x7fffffffe200 —▸ 0x404f10 (__libc_csu_init) ◂— ...
//  RIP  0x4012a0 (test+50) ◂— mov    eax, dword ptr [rax]
//         printf("RAX:                       %x\n",context->uc_mcontext.gregs[REG_RAX]);
//         printf("RBX:                       %x\n",context->uc_mcontext.gregs[REG_RBX]);
//         printf("RCX:                       %x\n",context->uc_mcontext.gregs[REG_RCX]);
//         printf("RDX:                       %x\n",context->uc_mcontext.gregs[REG_RDX]);
//         printf("RDI:                       %x\n",context->uc_mcontext.gregs[REG_RDI]);
//         printf("RSI:                       %x\n",context->uc_mcontext.gregs[REG_RSI]);
//         printf("R8:                        %x\n",context->uc_mcontext.gregs[REG_R8]);
//         printf("R9:                        %x\n",context->uc_mcontext.gregs[REG_R9]);
//         printf("R10:                       %x\n",context->uc_mcontext.gregs[REG_R10]);
//         printf("R11:                       %x\n",context->uc_mcontext.gregs[REG_R11]);
//         printf("R12:                       %x\n",context->uc_mcontext.gregs[REG_R12]);
//         printf("R13:                       %x\n",context->uc_mcontext.gregs[REG_R13]);
//         printf("R14:                       %x\n",context->uc_mcontext.gregs[REG_R14]);
//         printf("R15:                       %x\n",context->uc_mcontext.gregs[REG_R15]);
//         printf("RBP:                       %x\n",context->uc_mcontext.gregs[REG_RBP]);
//         printf("RSP:                       %x\n",context->uc_mcontext.gregs[REG_RSP]);
//         printf("RIP:                       %x\n",context->uc_mcontext.gregs[REG_RIP]);
//         printf("EFL:                       %x\n",context->uc_mcontext.gregs[REG_EFL]);
//         printf("CSGSFS:                    %x\n",context->uc_mcontext.gregs[REG_CSGSFS]);
//         printf("ERR:                       %x\n",context->uc_mcontext.gregs[REG_ERR]);
//         printf("TRAPNO:                    %x\n",context->uc_mcontext.gregs[REG_TRAPNO]);
//         printf("OLDMASK:                   %x\n",context->uc_mcontext.gregs[REG_OLDMASK]);
//         printf("CR2:                       %x\n",context->uc_mcontext.gregs[REG_CR2]);
//         context->uc_mcontext.gregs[REG_RIP] = context->uc_mcontext.gregs[REG_RIP] + 0x02 ;
//         printf("Next Address:              %x\n",context->uc_mcontext.gregs[REG_RIP]);
        signal(SIGSEGV, h);
        longjmp(restore_point, SIGSEGV);
    }
}

void
init_handler() {
    sa.sa_flags = SA_SIGINFO|SA_NODEFER;
    sigemptyset(&sa.sa_mask);
    sa.sa_sigaction = Handler;
    if (sigaction(SIGSEGV, &sa, NULL) == -1)
        perror("failed to set handler");
//     if (sigaction(SIGHUP, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGINT, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGQUIT, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGILL, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGTRAP, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGABRT, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGBUS, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGFPE, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGKILL, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGUSR1, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGUSR2, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGPIPE, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGALRM, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGTERM, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGSTKFLT, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGCLD, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGCONT, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGSTOP, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGTSTP, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGTTIN, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGTTOU, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGURG, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGXCPU, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGXFSZ, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGVTALRM, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGPROF, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGWINCH, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGPOLL, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGPWR, &sa, NULL) == -1)
//         perror("failed to set handler");
//     if (sigaction(SIGSYS, &sa, NULL) == -1)
//         perror("failed to set handler");
}


int test(char * address)
{
    init_handler();
    int fault_code = setjmp(restore_point);
    if (fault_code == 0)
    {
        /*
        if this seg faults in gdb, pass "handle SIGSEGV nostop pass noprint" to gdb command line to allow the hander init_handler() to handle this instead of gdb:
        (gdb) handle SIGSEGV nostop pass noprint
        <enter>
        (gdb) r
        <enter>
        
        if u use pwndbg the instructions are the same:
        pwndbg> handle SIGSEGV nostop pass noprint
        <enter>
        pwndbg> r
        <enter>
            
        alternatively start gdb like this (this assumes this is run inside a script and the executable this is compiled into is named ./loader and compiled with  test_loader.c containing a
        main() { 
            ... ;
            return 0;
        }
        with return 0; being on line 22, note the ... signifies a variable amount of text as we do not know what code main() {} can contain) :

        gdb ./loader -ex "set args $1" -ex "break test_loader.c:22" -ex "handle SIGSEGV nostop pass noprint" -ex "r"

        else this works fine:

        gdb <file> -ex "handle SIGSEGV nostop pass noprint" -ex "r"


        */
        printf("value: %15d\t", *(int*)address);
        return 0;
    }
    else
    {
        printf("value: %s\t", "     is not int");
        return -1;
    }
}

int testh(char * address)
{
    init_handler();
    int fault_code = setjmp(restore_point);
    if (fault_code == 0)
    {
        /*
        if this seg faults in gdb, pass "handle SIGSEGV nostop pass noprint" to gdb command line to allow the hander init_handler() to handle this instead of gdb:
        (gdb) handle SIGSEGV nostop pass noprint
        <enter>
        (gdb) r
        <enter>
        
        if u use pwndbg the instructions are the same:
        pwndbg> handle SIGSEGV nostop pass noprint
        <enter>
        pwndbg> r
        <enter>
            
        alternatively start gdb like this (this assumes this is run inside a script and the executable this is compiled into is named ./loader and compiled with  test_loader.c containing a
        main() { 
            ... ;
            return 0;
        }
        with return 0; being on line 22, note the ... signifies a variable amount of text as we do not know what code main() {} can contain) :

        gdb ./loader -ex "set args $1" -ex "break test_loader.c:22" -ex "handle SIGSEGV nostop pass noprint" -ex "r"

        else this works fine:

        gdb <file> -ex "handle SIGSEGV nostop pass noprint" -ex "r"


        */
        printf("value: %15x\t", *(int*)address);
        return 0;
    }
    else
    {
        printf("value: %s\t", "     is not hex");
        return -1;
    }
}

static int
callback(struct dl_phdr_info *info, size_t size, void *data)
{
    int j;
    Elf64_Phdr * tmp99;

    printf("name=%s (%d segments)\n", info->dlpi_name,
        info->dlpi_phnum);
        if (bytecmp(info->dlpi_name, argv[1]) == 0) for (j = 0; j < info->dlpi_phnum; j++) {
        printf("\t\t header %2d: address=%14p (%014p)\n", j, (void *) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr), (void *) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr));
        printf("\t\t p_type:\t\t\t/* Segment type */\t\t= ");
        switch(info->dlpi_phdr[j].p_type)
        {
            case PT_NULL:
                printf("PT_NULL\t\t/* Program header table entry unused */\n");
                break;
            case PT_LOAD:
                printf("PT_LOAD\t\t/* Loadable program segment */\n");
                break;
            case PT_DYNAMIC:
                printf("PT_DYNAMIC\t\t/* Dynamic linking information */\n");
                break;
            case PT_INTERP:
                printf("PT_INTERP\t\t/* Program interpreter */\n");
                break;
            case PT_NOTE:
                printf("PT_NOTE\t\t/* Auxiliary information */\n");
                break;
            case PT_SHLIB:
                printf("PT_SHLIB\t\t/* Reserved */\n");
                break;
            case PT_PHDR:
                printf("PT_PHDR\t\t/* Entry for header table itself */\n");
                break;
            case PT_TLS:
                printf("PT_TLS\t\t/* Thread-local storage segment */\n");
                break;
            case PT_NUM:
                printf("PT_NUM\t\t/* Number of defined types */\n");
                break;
            case PT_LOOS:
                printf("PT_LOOS\t\t/* Start of OS-specific */\n");
                break;
            case PT_GNU_EH_FRAME:
                printf("PT_GNU_EH_FRAME\t/* GCC .eh_frame_hdr segment */\n");
                break;
            case PT_GNU_STACK:
                printf("PT_GNU_STACK\t\t/* Indicates stack executability */\n");
                break;
            case PT_GNU_RELRO:
                printf("PT_GNU_RELRO\t\t/* Read-only after relocation */\n");
                break;
            case PT_SUNWBSS:
                printf("PT_SUNWBSS\t\t/* Sun Specific segment */\n");
                break;
            case PT_SUNWSTACK:
                printf("PT_SUNWSTACK\t\t/* Stack segment */\n");
                break;
            case PT_HIOS:
                printf("PT_HIOS\t\t/* End of OS-specific */\n");
                break;
            case PT_LOPROC:
                printf("PT_LOPROC\t\t/* Start of processor-specific */\n");
                break;
            case PT_HIPROC:
                printf("PT_HIPROC\t\t/* End of processor-specific */\n");
                break;
            default:
                    printf("\t\t Unknown\n");
            break;
        }
//         tmp99 = info->dlpi_phdr[j].p_offset;

        printf("\t\t reading                 %014p\n", (info->dlpi_phdr[j].p_memsz + info->dlpi_phdr[j].p_offset));
        char * tmp98[info->dlpi_phdr[j].p_memsz];
        *tmp98 = info->dlpi_phdr[j].p_offset;
//         printf("tmp98[0] = %c\n", tmp98[3]);
//         read_fast_verify(array, len, &tmp99, (info->dlpi_phdr[j].p_memsz + info->dlpi_phdr[j].p_offset));

        printf("\t\t correcting position by  %014p\n", info->dlpi_phdr[j].p_offset);
//         __lseek_string__(&tmp99, info->dlpi_phdr[j].p_memsz, info->dlpi_phdr[j].p_offset);

        printf("\t\t reading                 %d\n", info->dlpi_phdr[j].p_memsz);
        __print_quoted_string__(tmp98, info->dlpi_phdr[j].p_memsz, 0, "print");

        printf("\t\t p_flags:\t\t/* Segment flags */\t\t= %014p\n", info->dlpi_phdr[j].p_flags);
        printf("\t\t p_offset:\t\t/* Segment file offset */\t= %014p\n", info->dlpi_phdr[j].p_offset);
        printf("\t\t p_vaddr:\t\t/* Segment virtual address */\t= %014p\n", info->dlpi_phdr[j].p_vaddr);
        printf("\t\t p_paddr:\t\t/* Segment physical address */\t= %014p\n", info->dlpi_phdr[j].p_paddr);
        printf("\t\t p_filesz:\t\t/* Segment size in file */\t= %014p\n", info->dlpi_phdr[j].p_filesz);
        printf("\t\t p_memsz:\t\t/* Segment size in memory */\t= %014p\n", info->dlpi_phdr[j].p_memsz);
        printf("\t\t p_align:\t\t/* Segment alignment */\t\t= %014p\n", info->dlpi_phdr[j].p_align);

//         test(tmp99);
        printf("\n\n");
    }
    return 0;
}

#include <string.h>
#include <unistd.h>
#include <locale.h>
#include <elf.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/mman.h>
uintptr_t mappingb;
#define QUOTE_0_TERMINATED			0x01
#define QUOTE_OMIT_LEADING_TRAILING_QUOTES	0x02
#define QUOTE_OMIT_TRAILING_0			0x08
#define QUOTE_FORCE_HEX				0x10
#define QUOTE_FORCE_HEXOLD				9998
#define QUOTE_FORCE_LEN				9999
#define error_msg printf
Elf64_Ehdr *_elf_header;
Elf64_Phdr *_elf_program_header;
Elf64_Shdr *_elf_symbol_table;
char * program_hdr;
size_t len;
char * array;

char * init(char * lib) {
    if (array == NULL) {
        int fd = open(lib, O_RDONLY);
        if (fd < 0) {
            printf("cannot open \"%s\", returned %i\n", lib, fd);
            return -1;
        }
        len = 0;
        len = lseek(fd, 0, SEEK_END);
        lseek(fd, 0, 0);
        array = mmap (NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
        if (array == MAP_FAILED) {
            printf ("map failed\n");
            exit;
        } else {
            printf ("map succeded with address: %014p\n", array);
            return array;
        }
    } else return array;
    return "-1";
}
int is_mapped = 0;
int PT_DYNAMIC_ = NULL;
char * tmp99D;
int First_Load_Header_index = NULL;
int Last_Load_Header_index = NULL;
void map() {
    if (is_mapped == 0) {
        Elf64_Ehdr * _elf_header = (Elf64_Ehdr *) array;
        _elf_program_header = (Elf64_Phdr *)((unsigned long)_elf_header + _elf_header->e_phoff);

// the very first thing we do is obtain the base address

// Base Address
// The virtual addresses in the program headers might not represent the actual virtual addresses
// of the program's memory image. Executable files typically contain absolute code. To let the
// process execute correctly, the segments must reside at the virtual addresses used to build the
// executable file. On the other hand, shared object segments typically contain
// position-independent code. This lets a segment's virtual address change from one process to
// another, without invalidating execution behavior. Though the system chooses virtual addresses
// for individual processes, it maintains the segments’ relative positions. Because
// position-independent code uses relative addressing between segments, the difference between
// virtual addresses in memory must match the difference between virtual addresses in the file.
// 
// The difference between the virtual address of any segment in memory and the corresponding
// virtual address in the file is thus a single constant value for any one executable or shared object
// in a given process. This difference is the base address. One use of the base address is to relocate
// the memory image of the program during dynamic linking.
// 
// An executable or shared object file's base address is calculated during execution from three
// values: the virtual memory load address, the maximum page size, and the lowest virtual address
// of a program's loadable segment. To compute the base address, one determines the memory
// address associated with the lowest p_vaddr value for a PT_LOAD segment. This address is
// truncated to the nearest multiple of the maximum page size. The corresponding p_vaddr value
// itself is also truncated to the nearest multiple of the maximum page size. The base address is
// the difference between the truncated memory address and the truncated p_vaddr value.

        int PT_LOADS=0;
        for (int i = 0; i < _elf_header->e_phnum; ++i) {
            switch(_elf_program_header[i].p_type)
            {
                case PT_LOAD:
//                         printf("i = %d\n", i);
//                         printf("PT_LOADS = %d\n", PT_LOADS);
                    if (!PT_LOADS)  {
//                             printf("saving first load\n");
                        First_Load_Header_index = i;
                    }
                    if (PT_LOADS) {
//                             printf("saving last load\n");
                        Last_Load_Header_index = i;
                    }
                    PT_LOADS=PT_LOADS+1;
                    break;
            }
        }
        size_t span = _elf_program_header[Last_Load_Header_index].p_vaddr + _elf_program_header[Last_Load_Header_index].p_memsz - _elf_program_header[First_Load_Header_index].p_vaddr;

        size_t pagesize = 0x1000;

        read_fast_verifyb(array, len, &mappingb, span, _elf_program_header[First_Load_Header_index], _elf_program_header[Last_Load_Header_index]);

        align = round_down(_elf_program_header[Last_Load_Header_index].p_vaddr, pagesize);
        base_address = mappingb - align;
        mappingb_end = mappingb+span;

//             printf("base address range = %014p - %014p\nmapping = %014p\n", mappingb, mappingb_end, mapping);

// base address aquired, map all PT_LOAD segments adjusting by base address then continue with the rest
        printf("\n\n\nfind %014p, %014p, (int) 1239\n\n\n\n", mappingb, mappingb_end);

        if (mappingb == 0x00000000) abort_();
        int PT_LOADS_CURRENT = 0;
        for (int i = 0; i < _elf_header->e_phnum; ++i) {
            switch(_elf_program_header[i].p_type)
            {
                case PT_LOAD:
                    PT_LOADS_CURRENT = PT_LOADS_CURRENT + 1;
//                         printf ("mapping PT_LOAD number %d\n", PT_LOADS_CURRENT);
//                         printf("\t\tp_flags:  %014p\n", _elf_program_header[i].p_flags);
//                         printf("\t\tp_offset: %014p\n", _elf_program_header[i].p_offset);
//                         printf("\t\tp_vaddr:  %014p\n", _elf_program_header[i].p_vaddr+mappingb);
//                         printf("\t\tp_paddr:  %014p\n", _elf_program_header[i].p_paddr);
//                         printf("\t\tp_filesz: %014p\n", _elf_program_header[i].p_filesz);
//                         printf("\t\tp_memsz:  %014p\n", _elf_program_header[i].p_memsz);
//                         printf("\t\tp_align:  %014p\n\n", _elf_program_header[i].p_align);
// 
//                         printf("\tp_flags: %014p", _elf_program_header[i].p_flags);
//                         printf(" p_offset: %014p", _elf_program_header[i].p_offset);
//                         printf(" p_vaddr: %014p", _elf_program_header[i].p_vaddr+mappingb);
//                         printf(" p_paddr: %014p", _elf_program_header[i].p_paddr);
//                         printf(" p_filesz: %014p", _elf_program_header[i].p_filesz);
//                         printf(" p_memsz: %014p", _elf_program_header[i].p_memsz);
//                         printf(" p_align: %014p\n\n\n", _elf_program_header[i].p_align);

                    printf("mprotect(%014p+round_down(%014p, %014p), %014p, %014p);\n", mappingb, _elf_program_header[i].p_vaddr, _elf_program_header[i].p_align, _elf_program_header[i].p_memsz, _elf_program_header[i].p_flags);
                    
                    int check_map_success = mprotect(mappingb+round_down(_elf_program_header[i].p_vaddr, _elf_program_header[i].p_align), round_up(_elf_program_header[i].p_memsz, _elf_program_header[i].p_align), _elf_program_header[i].p_flags);
                    if (errno == 0)
                    {
                        printf ("mprotect on %014p succeded with size: %014p\n", mappingb+round_down(_elf_program_header[i].p_vaddr, _elf_program_header[i].p_align), round_up(_elf_program_header[i].p_memsz, _elf_program_header[i].p_align));
                        print_maps();
                    }
                    else
                    {
                        printf ("mprotect failed with: %s (errno: %d)\n", strerror(errno), errno);
                        print_maps();
                        abort_();
                    }
                    break;
            }
        }
        is_mapped = 1;
    }
}
// not used but kept incase needed
void __lseek_string__(char **src, int len, int offset) {
    char *p = malloc(len);
    memcpy(p, *src+offset, len);
    *src = p;
}

// not used but kept incase needed, a version of lseek_string that has an offset multiplier as so this does not need to be specified multiple times, eg if offset is 64 and multiplier is 2 the offset is then 128, this is intended for loops and related
void __lseek_stringb__(char **src, int len, int offset, int offsetT) {
    char *p = malloc(len);
    int off;
    off=((len*offsetT));
    memcpy(p, *src+offset+off, len);
    *src = p;
}
int __stream__(char *file, char **p, int *q, int LINES_TO_READ) {
            const char *filename = file;
            int fd = open(filename, O_RDONLY);
            if (fd < 0) {
                printf("cannot open \"%s\", returned %i\n", filename, fd);
                return -1;
            }
            char * array;
            char ch;
            size_t lines = 1;
            // Read the file byte by byte
            int bytes=1;
            int count=1;
            array = malloc(sizeof(char) * 2048);
            char *array_tmp;
            while (read(fd, &ch, 1) == 1) {
            printf("\rbytes read: %'i", bytes);
                if (count == 1024) { array_tmp = realloc(array, bytes+1024);
                    if (array_tmp == NULL) {
                        printf("failed to allocate array to new size");
                        free(array);
                        exit(1);
                    } else {
                        array = array_tmp;
                    }
                    count=1;
                }
                array[bytes-1] = ch;
                if (ch == '\n') {
                    if (lines == LINES_TO_READ) {
                        break;
                    }
                    lines++;
                }
                count++;
                bytes++;
            }
            bytes--;
            array_tmp = realloc(array, bytes);
            if (array_tmp == NULL) {
                printf("failed to allocate array to new size");
                free(array);
                exit(1);
            } else {
                array = array_tmp;
            }
            printf("\rbytes read: %'i\n", bytes);
    *p = array;
    *q = bytes;
    return bytes;
}

// not used but kept incase needed, a version of stream__ that only outputs the last line read
int __streamb__(char *file, char **p, int *q, int LINES_TO_READ) {
            const char *filename = file;
            int fd = open(filename, O_RDONLY);
            if (fd < 0) {
                printf("cannot open \"%s\", returned %i\n", filename, fd);
                return -1;
            }
            char * array;
            char * array_tmp;
            char * array_lines;
            char * array_lines_tmp;
            char ch;
            size_t lines = 1;
            // Read the file byte by byte
            int bytes=1;
            int count=1;
            array = malloc(sizeof(char) * 2048);
            while (read(fd, &ch, 1) == 1) {
            printf("\rbytes read: %'i", bytes);
                if (count == 1024) { array_tmp = realloc(array, bytes+1024);
                    if (array_tmp == NULL) {
                        printf("failed to allocate array to new size");
                        free(array);
                        exit(1);
                    } else {
                        array = array_tmp;
                    }
                    count=1;
                }
                array[bytes-1] = ch;
                if (ch == '\n') {
                    printf("attempting to reset array\n");
                    if (lines == LINES_TO_READ) {
                        break;
                    } else {
                        // reset array to as if we just executed this function
                        int y;
                        for (y=0; y<bytes; y++) {
                            array[y] = 0;
                        }
                        free(array);
                        array = malloc(sizeof(char) * 2048);
                        bytes=1;
                        count=1;
                    }
                    lines++;
                }
//                 count++;
                bytes++;
            }
            bytes--;
            array_tmp = realloc(array, bytes);
            if (array_tmp == NULL) {
                printf("failed to allocate array to new size");
                free(array);
                exit(1);
            } else {
                array = array_tmp;
            }
            printf("\rbytes read: %'i\n", bytes);
    *p = array;
    *q = bytes;
    return bytes;
}

// reads a entire file
int __readb__(char *file, char **p, size_t *q) {
    int fd;
    size_t len = 0;
    char *o;
    if (!(fd = open(file, O_RDONLY)))
    {
        fprintf(stderr, "open() failure\n");
        return (1);
    }
    len = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, 0);
    if (!(o = malloc(len))) {
        fprintf(stderr, "failure to malloc()\n");
    }
    if ((read(fd, o, len)) == -1) {
        fprintf(stderr, "failure to read()\n");
    }
    int cl = close(fd);
    if (cl < 0) {
        printf("cannot close \"%s\", returned %i\n", file, cl);
        return -1;
    }
    *p = o;
    *q = len;
    return len;
}

int
__string_quote__(const char *instr, char *outstr, const unsigned int size, const unsigned int style);

#ifndef ALLOCA_CUTOFF
# define ALLOCA_CUTOFF	4032
#endif
#define use_alloca(n) ((n) <= ALLOCA_CUTOFF)

char *
__print_quoted_string__(const char *str, unsigned int size, const unsigned int style, const char * return_type)
{
    char *buf;
    char *outstr;
    unsigned int alloc_size;
    int rc;

    if (size && style & QUOTE_0_TERMINATED)
        --size;

    alloc_size = 4 * size;
    if (alloc_size / 4 != size) {
        error_msg("Out of memory");
        printf("???");
        return "-1";
    }
    alloc_size += 1 + (style & QUOTE_OMIT_LEADING_TRAILING_QUOTES ? 0 : 2);

    if (use_alloca(alloc_size)) {
        outstr = alloca(alloc_size);
        buf = NULL;
    } else {
        outstr = buf = malloc(alloc_size);
        if (!buf) {
            error_msg("Out of memory");
            printf("???");
            return "-1";
        }
    }

//         rc = string_quote(str, outstr, size, style);
    __string_quote__(str, outstr, size, style);
    if ( return_type == "return") {
        return outstr;
    } else if ( return_type == "print") {
        printf(outstr);
    }

    free(buf);
//         return rc;
}

// read section header table
int read_section_header_table_(const char * arrayb, Elf64_Ehdr * eh, Elf64_Shdr * sh_table[])
{
    *sh_table = (Elf64_Shdr *)(arrayb + eh->e_shoff);
    if(!sh_table) {
        printf("Failed to read table\n");
        return -1;
    }
    return 0;
}

char * read_section_(char * ar, Elf64_Shdr sh) {
    char * buff = (char *)(ar + sh.sh_offset);
    return buff ;
}

char * print_section_headers_(char * sourcePtr, Elf64_Ehdr * eh, Elf64_Shdr sh_table[]) {
    printf ("\n");
    printf("eh->e_shstrndx = 0x%x (%d)\n", eh->e_shstrndx+mappingb, eh->e_shstrndx);
    char * sh_str;
    sh_str = read_section_(sourcePtr, sh_table[eh->e_shstrndx]); // will fail untill section header table can be read
    printf("\t========================================");
    printf("========================================\n");
    printf("\tidx offset     load-addr  size       algn type       flags      section\n");
    printf("\t========================================");
    printf("========================================\n");

    for(int i=0; i<eh->e_shnum; i++) { // will fail untill section header table can be read
        printf("\t%03d ", i);
        printf("%014p ", _elf_symbol_table[i].sh_offset); // not sure if this should be adjusted to base address
        printf("%014p ", _elf_symbol_table[i].sh_addr+mappingb);
        printf("%014p ", _elf_symbol_table[i].sh_size);
        printf("%4d ", _elf_symbol_table[i].sh_addralign);
        printf("%014p ", _elf_symbol_table[i].sh_type);
        printf("%014p ", _elf_symbol_table[i].sh_flags);
        printf("%s\t", (sh_str + sh_table[i].sh_name));
        printf("\n");
    }
    printf("\t========================================");
    printf("========================================\n");
    printf("\n");
}

int symbol1(char * arrayc, Elf64_Sym sym_tbl[], uint64_t symbol_table) {
    uint64_t i, symbol_count;


//   Elf64_Word	st_name;		/* Symbol name (string tbl index) */
//   unsigned char	st_info;		/* Symbol type and binding */
//   unsigned char st_other;		/* Symbol visibility */
//   Elf64_Section	st_shndx;		/* Section index */
//   Elf64_Addr	st_value;		/* Symbol value */
//   Elf64_Xword	st_size;		/* Symbol size */
    for(int i=0; i< 40; i++) {
        printf("index: %d\t", i);
        printf("size: %d \t", sym_tbl[i].st_size);
// /* Legal values for ST_BIND subfield of st_info (symbol binding).  */
// 
// #define STB_LOCAL	0		/* Local symbol */
// #define STB_GLOBAL	1		/* Global symbol */
// #define STB_WEAK	2		/* Weak symbol */
// #define	STB_NUM		3		/* Number of defined types.  */
// #define STB_LOOS	10		/* Start of OS-specific */
// #define STB_GNU_UNIQUE	10		/* Unique symbol.  */
// #define STB_HIOS	12		/* End of OS-specific */
// #define STB_LOPROC	13		/* Start of processor-specific */
// #define STB_HIPROC	15		/* End of processor-specific */
        printf("binding: ");
        switch (ELF64_ST_BIND(sym_tbl[i].st_info)) {
            case STB_LOCAL:
                printf("LOCAL  ( Local  symbol )   ");
                break;
            case STB_GLOBAL:
                printf("GLOBAL ( Global symbol )   ");
                break;
            case STB_WEAK:
                printf("WEAK   (  Weak symbol  )   ");
                break;
            default:
                printf("UNKNOWN (%d)               ", ELF64_ST_BIND(sym_tbl[i].st_info));
                break;
        }
// /* Legal values for ST_TYPE subfield of st_info (symbol type).  */
// 
// #define STT_NOTYPE	0		/* Symbol type is unspecified */
// #define STT_OBJECT	1		/* Symbol is a data object */
// #define STT_FUNC	2		/* Symbol is a code object */
// #define STT_SECTION	3		/* Symbol associated with a section */
// #define STT_FILE	4		/* Symbol's name is file name */
// #define STT_COMMON	5		/* Symbol is a common data object */
// #define STT_TLS		6		/* Symbol is thread-local data object*/
// #define	STT_NUM		7		/* Number of defined types.  */
// #define STT_LOOS	10		/* Start of OS-specific */
// #define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
// #define STT_HIOS	12		/* End of OS-specific */
// #define STT_LOPROC	13		/* Start of processor-specific */
// #define STT_HIPROC	15		/* End of processor-specific */
// /* Symbol visibility specification encoded in the st_other field.  */
// #define STV_DEFAULT	0		/* Default symbol visibility rules */
// #define STV_INTERNAL	1		/* Processor specific hidden class */
// #define STV_HIDDEN	2		/* Sym unavailable in other modules */
// #define STV_PROTECTED	3		/* Not preemptible, not exported */
        printf("visibility: ");
        switch (ELF64_ST_VISIBILITY(sym_tbl[i].st_other)) {
            case STV_DEFAULT:
                printf("default (Default symbol visibility rules)        ");
                break;
            case STV_INTERNAL:
                printf("internal (Processor specific hidden class)       ");
                break;
            case STV_HIDDEN:
                printf("hidden (Symbol unavailable in other modules)     ");
                break;
            case STV_PROTECTED:
                printf("protected (Not preemptible, not exported)        ");
                break;
        }
        printf("type: ");
        switch (ELF64_ST_TYPE(sym_tbl[i].st_info)) {
            case STT_NOTYPE:
                printf("NOTYPE   (Symbol type is unspecified)             ");
                break;
            case STT_OBJECT:
                printf("OBJECT   (Symbol is a data object)                ");
                break;
                case STT_FUNC:
                printf("FUNCTION (Symbol is a code object)                ");
                break;
                case STT_SECTION:
                printf("SECTION  (Symbol associated with a section)       ");
                break;
                case STT_FILE:
                printf("FILE     (Symbol's name is file name)             ");
                break;
                case STT_COMMON:
                printf("COMMON   (Symbol is a common data object)         ");
                break;
                case STT_TLS:
                printf("TLS      (Symbol is thread-local data object)     ");
                break;
            default:
                printf("UNKNOWN (%d)                                      ", ELF64_ST_TYPE(sym_tbl[i].st_info));
                break;
        }
        if ( ELF64_ST_TYPE(sym_tbl[i].st_info) == STT_FUNC)
            printf("address: %014p\t", sym_tbl[i].st_value+mappingb+align);
        else
            printf("address: %014p\t", sym_tbl[i].st_value+mappingb);
        printf("name: [Not obtained due to unavailability]\n");
    }
}

int symbol(char * arrayc, Elf64_Shdr sh_table[], uint64_t symbol_table) {
    char *str_tbl;
    Elf64_Sym* sym_tbl;
    uint64_t i, symbol_count;
    printf("symbol_table = %d\n", symbol_table);
    sym_tbl = (Elf64_Sym*)read_section_(arrayc, sh_table[symbol_table]);

    /* Read linked string-table
    * Section containing the string table having names of
    * symbols of this section
    */
    uint64_t str_tbl_ndx = sh_table[symbol_table].sh_link;
    printf("string/symbol table index = %d\n", str_tbl_ndx);
    str_tbl = read_section_(arrayc, sh_table[str_tbl_ndx]);

    symbol_count = (sh_table[symbol_table].sh_size/sizeof(Elf64_Sym));
    int link_ = sh_table[symbol_table].sh_link;
    link_ = sh_table[link_].sh_link;
    int linkn = 0;
    while (link_ != 0) {
        link_ = sh_table[link_].sh_link;
        linkn++;
    }
    printf("links: %d\n", linkn);
    printf("%d symbols\n", symbol_count);

//   Elf64_Word	st_name;		/* Symbol name (string tbl index) */
//   unsigned char	st_info;		/* Symbol type and binding */
//   unsigned char st_other;		/* Symbol visibility */
//   Elf64_Section	st_shndx;		/* Section index */
//   Elf64_Addr	st_value;		/* Symbol value */
//   Elf64_Xword	st_size;		/* Symbol size */
    for(int i=0; i< symbol_count; i++) {
        printf("index: %d\t", i);
        printf("size: %10d \t", sym_tbl[i].st_size);
// /* Legal values for ST_BIND subfield of st_info (symbol binding).  */
// 
// #define STB_LOCAL	0		/* Local symbol */
// #define STB_GLOBAL	1		/* Global symbol */
// #define STB_WEAK	2		/* Weak symbol */
// #define	STB_NUM		3		/* Number of defined types.  */
// #define STB_LOOS	10		/* Start of OS-specific */
// #define STB_GNU_UNIQUE	10		/* Unique symbol.  */
// #define STB_HIOS	12		/* End of OS-specific */
// #define STB_LOPROC	13		/* Start of processor-specific */
// #define STB_HIPROC	15		/* End of processor-specific */
        printf("binding: ");
        switch (ELF64_ST_BIND(sym_tbl[i].st_info)) {
            case STB_LOCAL:
                printf("LOCAL   ( Local  symbol )  ");
                break;
            case STB_GLOBAL:
                printf("GLOBAL  ( Global symbol )  ");
                break;
            case STB_WEAK:
                printf("WEAK    (  Weak symbol  )  ");
                break;
            default:
                printf("UNKNOWN (%d)                ", ELF64_ST_BIND(sym_tbl[i].st_info));
                break;
        }
// /* Legal values for ST_TYPE subfield of st_info (symbol type).  */
// 
// #define STT_NOTYPE	0		/* Symbol type is unspecified */
// #define STT_OBJECT	1		/* Symbol is a data object */
// #define STT_FUNC	2		/* Symbol is a code object */
// #define STT_SECTION	3		/* Symbol associated with a section */
// #define STT_FILE	4		/* Symbol's name is file name */
// #define STT_COMMON	5		/* Symbol is a common data object */
// #define STT_TLS		6		/* Symbol is thread-local data object*/
// #define	STT_NUM		7		/* Number of defined types.  */
// #define STT_LOOS	10		/* Start of OS-specific */
// #define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
// #define STT_HIOS	12		/* End of OS-specific */
// #define STT_LOPROC	13		/* Start of processor-specific */
// #define STT_HIPROC	15		/* End of processor-specific */
// /* Symbol visibility specification encoded in the st_other field.  */
// #define STV_DEFAULT	0		/* Default symbol visibility rules */
// #define STV_INTERNAL	1		/* Processor specific hidden class */
// #define STV_HIDDEN	2		/* Sym unavailable in other modules */
// #define STV_PROTECTED	3		/* Not preemptible, not exported */
        printf("visibility: ");
        switch (ELF64_ST_VISIBILITY(sym_tbl[i].st_other)) {
            case STV_DEFAULT:
                printf("default   (Default symbol visibility rules)      ");
                break;
            case STV_INTERNAL:
                printf("internal  (Processor specific hidden class)      ");
                break;
            case STV_HIDDEN:
                printf("hidden    (Symbol unavailable in other modules)  ");
                break;
            case STV_PROTECTED:
                printf("protected (Not preemptible, not exported)        ");
                break;
        }
        char * address = sym_tbl[i].st_value+mappingb;
        printf("address: %014p\t", address);
        if ( address > mappingb && address < mappingb_end ) test(address);
        else printf("value: %15s\t", "invalid range");
        printf("type: ");
        switch (ELF64_ST_TYPE(sym_tbl[i].st_info)) {
            case STT_NOTYPE:
                printf("NOTYPE   (Symbol type is unspecified)             ");
                break;
            case STT_OBJECT:
                printf("OBJECT   (Symbol is a data object)                ");
                break;
                case STT_FUNC:
                printf("FUNCTION (Symbol is a code object)                ");
                break;
                case STT_SECTION:
                printf("SECTION  (Symbol associated with a section)       ");
                break;
                case STT_FILE:
                printf("FILE     (Symbol's name is file name)             ");
                break;
                case STT_COMMON:
                printf("COMMON   (Symbol is a common data object)         ");
                break;
                case STT_TLS:
                printf("TLS      (Symbol is thread-local data object)     ");
                break;
            default:
                printf("UNKNOWN  (%d)                                     ", ELF64_ST_TYPE(sym_tbl[i].st_info));
                break;
        }
        char * name = str_tbl + sym_tbl[i].st_name;
        printf("name: %s\n", demangle_it(name));
        nl();
        if (bytecmp(name,"t") == 0) {

            printf("t found\n");
                        
// #define JMP_ADDR(x) asm("\tjmp  *%0\n" :: "r" (x))
//             printf("(%014p+%014p=%014p)\n", mappingb, sym_tbl[i].st_value, sym_tbl[i].st_value+mappingb);
//             printf("JMP_ADDR(%014p);\n", address);
//             JMP_ADDR(address);
                        printf("int (*testb)()                               =%014p\n", address);
// 
            printf("(%014p+%014p=%014p)\n", mappingb, sym_tbl[i].st_value, sym_tbl[i].st_value+mappingb);
// 
            int (*testb)() = lookup_symbol_by_name_("/chakra/home/universalpackagemanager/chroot/arch-chroot/arch-pkg-build/packages/glibc/repos/core-x86_64/min-dl/loader/files/test_lib.so", "t");
            printf("testb = %014p\n", testb);
            printf("testb() returned %d;\n",
            testb()
            );

            nl();
//             int (*testc)() = mappingb+sym_tbl[i].st_value;
//             printf("int (*testc)()                =%014p ; testc();\n", mappingb+sym_tbl[i].st_value);
//             testc();
//             nl();
//             int foo(int i){ return i + 1;}
// 
//             typedef int (*g)(int);  // Declare typedef
// 
//             g func = mappingb+sym_tbl[i].st_value;          // Define function-pointer variable, and initialise
// 
//             int hvar = func(3);     // Call function through pointer
            nl();
            print_maps();
        }
    }
}

int relocation(char * arrayc, Elf64_Shdr sh_table[], uint64_t symbol_table) {
    char *str_tbl;
    Elf64_Sym* sym_tbl;
    uint64_t i, symbol_count;

    sym_tbl = (Elf64_Sym*)read_section_(arrayc, sh_table[symbol_table]);

    /* Read linked string-table
    * Section containing the string table having names of
    * symbols of this section
    */
    uint64_t str_tbl_ndx = sh_table[symbol_table].sh_link;
    printf("string/symbol table index = %d\n", str_tbl_ndx);
    str_tbl = read_section_(arrayc, sh_table[str_tbl_ndx]);

    symbol_count = (sh_table[symbol_table].sh_size/sizeof(Elf64_Sym));
    int link_ = sh_table[symbol_table].sh_link;
    link_ = sh_table[link_].sh_link;
    int linkn = 0;
    while (link_ != 0) {
        link_ = sh_table[link_].sh_link;
        linkn++;
    }
    printf("links: %d\n", linkn);
    printf("%d symbols\n", symbol_count);

//   Elf64_Word	st_name;		/* Symbol name (string tbl index) */
//   unsigned char	st_info;		/* Symbol type and binding */
//   unsigned char st_other;		/* Symbol visibility */
//   Elf64_Section	st_shndx;		/* Section index */
//   Elf64_Addr	st_value;		/* Symbol value */
//   Elf64_Xword	st_size;		/* Symbol size */
    for(int i=0; i< symbol_count; i++) {
        printf("index: %d\t", i);
        printf("size: %10d \t", sym_tbl[i].st_size);
// /* Legal values for ST_BIND subfield of st_info (symbol binding).  */
// 
// #define STB_LOCAL	0		/* Local symbol */
// #define STB_GLOBAL	1		/* Global symbol */
// #define STB_WEAK	2		/* Weak symbol */
// #define	STB_NUM		3		/* Number of defined types.  */
// #define STB_LOOS	10		/* Start of OS-specific */
// #define STB_GNU_UNIQUE	10		/* Unique symbol.  */
// #define STB_HIOS	12		/* End of OS-specific */
// #define STB_LOPROC	13		/* Start of processor-specific */
// #define STB_HIPROC	15		/* End of processor-specific */
        printf("binding: ");
        switch (ELF64_ST_BIND(sym_tbl[i].st_info)) {
            case STB_LOCAL:
                printf("LOCAL   ( Local  symbol )  ");
                break;
            case STB_GLOBAL:
                printf("GLOBAL  ( Global symbol )  ");
                break;
            case STB_WEAK:
                printf("WEAK    (  Weak symbol  )  ");
                break;
            default:
                printf("UNKNOWN (%d)                ", ELF64_ST_BIND(sym_tbl[i].st_info));
                break;
        }
// /* Legal values for ST_TYPE subfield of st_info (symbol type).  */
// 
// #define STT_NOTYPE	0		/* Symbol type is unspecified */
// #define STT_OBJECT	1		/* Symbol is a data object */
// #define STT_FUNC	2		/* Symbol is a code object */
// #define STT_SECTION	3		/* Symbol associated with a section */
// #define STT_FILE	4		/* Symbol's name is file name */
// #define STT_COMMON	5		/* Symbol is a common data object */
// #define STT_TLS		6		/* Symbol is thread-local data object*/
// #define	STT_NUM		7		/* Number of defined types.  */
// #define STT_LOOS	10		/* Start of OS-specific */
// #define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
// #define STT_HIOS	12		/* End of OS-specific */
// #define STT_LOPROC	13		/* Start of processor-specific */
// #define STT_HIPROC	15		/* End of processor-specific */
// /* Symbol visibility specification encoded in the st_other field.  */
// #define STV_DEFAULT	0		/* Default symbol visibility rules */
// #define STV_INTERNAL	1		/* Processor specific hidden class */
// #define STV_HIDDEN	2		/* Sym unavailable in other modules */
// #define STV_PROTECTED	3		/* Not preemptible, not exported */
        printf("visibility: ");
        switch (ELF64_ST_VISIBILITY(sym_tbl[i].st_other)) {
            case STV_DEFAULT:
                printf("default   (Default symbol visibility rules)      ");
                break;
            case STV_INTERNAL:
                printf("internal  (Processor specific hidden class)      ");
                break;
            case STV_HIDDEN:
                printf("hidden    (Symbol unavailable in other modules)  ");
                break;
            case STV_PROTECTED:
                printf("protected (Not preemptible, not exported)        ");
                break;
        }
        char * address;
        if ( ELF64_ST_TYPE(sym_tbl[i].st_info) == STT_FUNC)
        {
            address = sym_tbl[i].st_value+mappingb+align;
            printf("address: %014p\t", address);
        }
        else
        {
            address = sym_tbl[i].st_value+mappingb;
            printf("address: %014p\t", address);
        }
        if ( address > mappingb && address < mappingb_end ) test(address);
        else printf("value: %15s\t", "invalid range");
        printf("type: ");
        switch (ELF64_ST_TYPE(sym_tbl[i].st_info)) {
            case STT_NOTYPE:
                printf("NOTYPE   (Symbol type is unspecified)             ");
                break;
            case STT_OBJECT:
                printf("OBJECT   (Symbol is a data object)                ");
                break;
                case STT_FUNC:
                printf("FUNCTION (Symbol is a code object)                ");
                break;
                case STT_SECTION:
                printf("SECTION  (Symbol associated with a section)       ");
                break;
                case STT_FILE:
                printf("FILE     (Symbol's name is file name)             ");
                break;
                case STT_COMMON:
                printf("COMMON   (Symbol is a common data object)         ");
                break;
                case STT_TLS:
                printf("TLS      (Symbol is thread-local data object)     ");
                break;
            default:
                printf("UNKNOWN  (%d)                                     ", ELF64_ST_TYPE(sym_tbl[i].st_info));
                break;
        }
        printf("name: [Not obtained due to it may crash this program]\n");
//         printf("\n");
    }
}

void print_elf_symbol_table(char * arrayc, Elf64_Ehdr * eh, Elf64_Shdr sh_table[], uint64_t symbol_table)
{
    int level = 0;
        switch(sh_table[symbol_table].sh_type) {
            case SHT_NULL:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_PROGBITS:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_SYMTAB:
                symbol(arrayc, sh_table, symbol_table);
                break;
            case SHT_STRTAB:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_RELA:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_HASH:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_DYNAMIC:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_NOTE:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_NOBITS:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_REL:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_SHLIB:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_DYNSYM:
                symbol(arrayc, sh_table, symbol_table);
                break;
            case SHT_INIT_ARRAY:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_FINI_ARRAY:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_PREINIT_ARRAY:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_GROUP:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_SYMTAB_SHNDX:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_NUM:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOOS:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_ATTRIBUTES:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_HASH:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_LIBLIST:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_CHECKSUM:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOSUNW:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_SUNW_COMDAT:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_SUNW_syminfo:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_verdef:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_verneed:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_versym:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOPROC:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_HIPROC:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOUSER:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            case SHT_HIUSER:
                if (level == 3) relocation(arrayc, sh_table, symbol_table);
                break;
            default:
                printf("UNKNOWN ");
                break;
        }
}

void print_symbols(char * arrayd, Elf64_Ehdr * eh, Elf64_Shdr sh_table[])
{
// /* Legal values for sh_type (section type).  */
// 
// #define SHT_NULL	  0		/* Section header table entry unused */
// #define SHT_PROGBITS	  1		/* Program data */
// #define SHT_SYMTAB	  2		/* Symbol table */
// #define SHT_STRTAB	  3		/* String table */
// #define SHT_RELA	  4		/* Relocation entries with addends */
// #define SHT_HASH	  5		/* Symbol hash table */
// #define SHT_DYNAMIC	  6		/* Dynamic linking information */
// #define SHT_NOTE	  7		/* Notes */
// #define SHT_NOBITS	  8		/* Program space with no data (bss) */
// #define SHT_REL		  9		/* Relocation entries, no addends */
// #define SHT_SHLIB	  10		/* Reserved */
// #define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
// #define SHT_INIT_ARRAY	  14		/* Array of constructors */
// #define SHT_FINI_ARRAY	  15		/* Array of destructors */
// #define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
// #define SHT_GROUP	  17		/* Section group */
// #define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
// #define	SHT_NUM		  19		/* Number of defined types.  */
// #define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
// #define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
// #define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
// #define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
// #define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
// #define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
// #define SHT_SUNW_move	  0x6ffffffa
// #define SHT_SUNW_COMDAT   0x6ffffffb
// #define SHT_SUNW_syminfo  0x6ffffffc
// #define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
// #define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
// #define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
// #define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
// #define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
// #define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
// #define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
// #define SHT_LOUSER	  0x80000000	/* Start of application-specific */
// #define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
    int ii = 0;
    for(int i=0; i<eh->e_shnum; i++) {
        printf("\n[");
        switch(sh_table[i].sh_type) {
            case SHT_NULL:
                printf("NULL                     (Section header table entry unused)                   ");
                break;
            case SHT_PROGBITS:
                printf("PROGBITS                 (Program data)                                        ");
                break;
            case SHT_SYMTAB: 
                printf("SYMTAB                   (Symbol table)                                        ");
                break;
            case SHT_STRTAB:
                printf("STRTAB                   (String table)                                        ");
                break;
            case SHT_RELA:
                printf("RELA                     (Relocation entries with addends)                     ");
                break;
            case SHT_HASH:
                printf("HASH                     (Symbol hash table)                                   ");
                break;
            case SHT_DYNAMIC:
                printf("DYNAMIC                  (Dynamic linking information)                         ");
                break;
            case SHT_NOTE:
                printf("NOTE                     (Notes)                                               ");
                break;
            case SHT_NOBITS:
                printf("NOBITS                   (Program space with no data (bss))                    ");
                break;
            case SHT_REL:
                printf("REL                      (Relocation entries, no addends)                      ");
                break;
            case SHT_SHLIB:
                printf("SHLIB                    (Reserved)                                            ");
                break;
            case SHT_DYNSYM:
                printf("DYNSYM                   (Dynamic linker symbol table)                         ");
                break;
            case SHT_INIT_ARRAY:
                printf("INIT_ARRAY               (Array of constructors)                               ");
                break;
            case SHT_FINI_ARRAY:
                printf("FINI_ARRAY               (Array of destructors)                                ");
                break;
            case SHT_PREINIT_ARRAY:
                printf("PREINIT_ARRAY            (Array of pre-constructors)                           ");
                break;
            case SHT_GROUP:
                printf("GROUP                    (Section group)                                       ");
                break;
            case SHT_SYMTAB_SHNDX:
                printf("SYMTAB_SHNDX             (Extended section indeces)                            ");
                break;
            case SHT_NUM:
                printf("NUM                      (Number of defined types)                             ");
                break;
            case SHT_LOOS:
                printf("LOOS                     (Start OS-specific)                                   ");
                break;
            case SHT_GNU_ATTRIBUTES:
                printf("GNU_ATTRIBUTES           (Object attributes)                                   ");
                break;
            case SHT_GNU_HASH:
                printf("GNU_HASH                 (GNU-style hash table)                                ");
                break;
            case SHT_GNU_LIBLIST:
                printf("GNU_LIBLIST              (Prelink library list)                                ");
                break;
            case SHT_CHECKSUM:
                printf("CHECKSUM                 (Checksum for DSO content)                            ");
                break;
            case SHT_LOSUNW:
                printf("LOSUNW or SUNW_move                                                            ");
                break;
            case SHT_SUNW_COMDAT:
                printf("SUNW_COMDAT                                                                    ");
                break;
            case SHT_SUNW_syminfo:
                printf("SUNW_syminfo                                                                   ");
                break;
            case SHT_GNU_verdef:
                printf("GNU_verdef               (Version definition section)                          ");
                break;
            case SHT_GNU_verneed:
                printf("GNU_verneed              (Version needs section)                               ");
                break;
            case SHT_GNU_versym:
                printf("GNU_versym               (Version symbol table) or HISUNW (Sun-specific high bound) or HIOS (End OS-specific type) ");
                break;
            case SHT_LOPROC:
                printf("LOPROC                   (Start of processor-specific)                         ");
                break;
            case SHT_HIPROC:
                printf("HIPROC                   (End of processor-specific)                           ");
                break;
            case SHT_LOUSER:
                printf("LOUSER                   (Start of application-specific)                       ");
                break;
            case SHT_HIUSER:
                printf("HIUSER                   (End of application-specific)                         ");
                break;
            default:
                printf("UNKNOWN                                                                        ");
        }
        printf("Section %d, Index %d]\n", ii, i);
        print_elf_symbol_table(arrayd, eh, sh_table, i);
        ii++;
    }
}

char * symbol_lookup(char * arrayc, Elf64_Shdr sh_table[], uint64_t symbol_table, int index) {
    printf("looking up index %d of table %d\n", index, symbol_table);
    Elf64_Sym* sym_tbl = (Elf64_Sym*)read_section_(arrayc, sh_table[symbol_table]);
    uint64_t str_tbl_ndx = sh_table[symbol_table].sh_link;
    char *str_tbl = read_section_(arrayc, sh_table[str_tbl_ndx]);
    uint64_t symbol_count = (sh_table[symbol_table].sh_size/sizeof(Elf64_Sym));
    printf("requested symbol name for index %d is %s\n", index, demangle_it(str_tbl + sym_tbl[index].st_name));
    return sym_tbl[index].st_value;
}

char * symbol_lookup_name(char * arrayc, Elf64_Shdr sh_table[], uint64_t symbol_table, char * name_) {
    char *str_tbl;
    Elf64_Sym* sym_tbl;
    uint64_t i, symbol_count;
    sym_tbl = (Elf64_Sym*)read_section_(arrayc, sh_table[symbol_table]);

    uint64_t str_tbl_ndx = sh_table[symbol_table].sh_link;
    str_tbl = read_section_(arrayc, sh_table[str_tbl_ndx]);

    symbol_count = (sh_table[symbol_table].sh_size/sizeof(Elf64_Sym));

    for(int i=0; i< symbol_count; i++) {
        char * name = demangle_it(str_tbl + sym_tbl[i].st_name);
        if (bytecmpq(name,name_) == 0) {
            char * address = sym_tbl[i].st_value+mappingb;
            printf("requested symbol name for lookup name %s is %s at address %014p\n", name_, name, address);
            return address;
        }
    }
    return NULL;
}

char * print_elf_symbol_table_lookup(char * arrayc, Elf64_Ehdr * eh, Elf64_Shdr sh_table[], uint64_t symbol_table, int index)
{
        switch(sh_table[symbol_table].sh_type) {
            case SHT_DYNSYM:
                return symbol_lookup(arrayc, sh_table, symbol_table, index);
                break;
            default:
                return (int) -1;
                break;
        }
}

char * print_elf_symbol_table_lookup_name(char * arrayc, Elf64_Ehdr * eh, Elf64_Shdr sh_table[], uint64_t symbol_table, char * index)
{
        char * name_;
        switch(sh_table[symbol_table].sh_type) {
            case SHT_DYNSYM:
                name_ = symbol_lookup_name(arrayc, sh_table, symbol_table, index);
                if (name_ != NULL) {
                    return name_;
                }
                else {
                    return NULL;
                }
                break;
            case SHT_SYMTAB:
                name_ = symbol_lookup_name(arrayc, sh_table, symbol_table, index);
                if (name_ != NULL) {
                    return name_;
                }
                else {
                    return NULL;
                }
                break;
            default:
                return NULL;
                break;
        }
}

char * print_symbols_lookup(char * arrayd, Elf64_Ehdr * eh, Elf64_Shdr sh_table[], int index)
{
    for(int i=0; i<eh->e_shnum; i++) {
        int value = print_elf_symbol_table_lookup(arrayd, eh, sh_table, i, index);
        if ( value != -1 ) return value;
    }
}

char * print_symbols_lookup_name(char * arrayd, Elf64_Ehdr * eh, Elf64_Shdr sh_table[], char * index)
{
    char * value;
    for(int i=0; i<eh->e_shnum; i++) {
        value = print_elf_symbol_table_lookup_name(arrayd, eh, sh_table, i, index);
        if ( value != NULL ) {
            return value;
        }
    }
    if (value == NULL) return NULL;

}

int relocation_got_and_plt(char * arrayc, Elf64_Shdr sh_table[], uint64_t symbol_table) {
    char *str_tbl;
    Elf64_Sym* sym_tbl;
    uint64_t i, symbol_count;

    sym_tbl = (Elf64_Sym*)read_section_(arrayc, sh_table[symbol_table]);

    /* Read linked string-table
    * Section containing the string table having names of
    * symbols of this section
    */
    uint64_t str_tbl_ndx = sh_table[symbol_table].sh_link;
    printf("string/symbol table index = %d\n", str_tbl_ndx);
    str_tbl = read_section_(arrayc, sh_table[str_tbl_ndx]);

    symbol_count = (sh_table[symbol_table].sh_size);
    int link_ = sh_table[symbol_table].sh_link;
    link_ = sh_table[link_].sh_link;
    int linkn = 0;
    while (link_ != 0) {
        link_ = sh_table[link_].sh_link;
        linkn++;
    }
    printf("links: %d\n", linkn);
    printf("%d symbols\n", symbol_count);

//   Elf64_Word	st_name;		/* Symbol name (string tbl index) */
//   unsigned char	st_info;		/* Symbol type and binding */
//   unsigned char st_other;		/* Symbol visibility */
//   Elf64_Section	st_shndx;		/* Section index */
//   Elf64_Addr	st_value;		/* Symbol value */
//   Elf64_Xword	st_size;		/* Symbol size */
    for(int i=0; i< symbol_count; i++) {
        printf("index: %d\t", i);
        printf("size: %10d \t", sym_tbl[i].st_size);
// /* Legal values for ST_BIND subfield of st_info (symbol binding).  */
// 
// #define STB_LOCAL	0		/* Local symbol */
// #define STB_GLOBAL	1		/* Global symbol */
// #define STB_WEAK	2		/* Weak symbol */
// #define	STB_NUM		3		/* Number of defined types.  */
// #define STB_LOOS	10		/* Start of OS-specific */
// #define STB_GNU_UNIQUE	10		/* Unique symbol.  */
// #define STB_HIOS	12		/* End of OS-specific */
// #define STB_LOPROC	13		/* Start of processor-specific */
// #define STB_HIPROC	15		/* End of processor-specific */
        printf("binding: ");
        switch (ELF64_ST_BIND(sym_tbl[i].st_info)) {
            case STB_LOCAL:
                printf("LOCAL   ( Local  symbol )  ");
                break;
            case STB_GLOBAL:
                printf("GLOBAL  ( Global symbol )  ");
                break;
            case STB_WEAK:
                printf("WEAK    (  Weak symbol  )  ");
                break;
            default:
                printf("UNKNOWN (%d)                ", ELF64_ST_BIND(sym_tbl[i].st_info));
                break;
        }
// /* Legal values for ST_TYPE subfield of st_info (symbol type).  */
// 
// #define STT_NOTYPE	0		/* Symbol type is unspecified */
// #define STT_OBJECT	1		/* Symbol is a data object */
// #define STT_FUNC	2		/* Symbol is a code object */
// #define STT_SECTION	3		/* Symbol associated with a section */
// #define STT_FILE	4		/* Symbol's name is file name */
// #define STT_COMMON	5		/* Symbol is a common data object */
// #define STT_TLS		6		/* Symbol is thread-local data object*/
// #define	STT_NUM		7		/* Number of defined types.  */
// #define STT_LOOS	10		/* Start of OS-specific */
// #define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
// #define STT_HIOS	12		/* End of OS-specific */
// #define STT_LOPROC	13		/* Start of processor-specific */
// #define STT_HIPROC	15		/* End of processor-specific */
// /* Symbol visibility specification encoded in the st_other field.  */
// #define STV_DEFAULT	0		/* Default symbol visibility rules */
// #define STV_INTERNAL	1		/* Processor specific hidden class */
// #define STV_HIDDEN	2		/* Sym unavailable in other modules */
// #define STV_PROTECTED	3		/* Not preemptible, not exported */
        printf("visibility: ");
        switch (ELF64_ST_VISIBILITY(sym_tbl[i].st_other)) {
            case STV_DEFAULT:
                printf("default   (Default symbol visibility rules)      ");
                break;
            case STV_INTERNAL:
                printf("internal  (Processor specific hidden class)      ");
                break;
            case STV_HIDDEN:
                printf("hidden    (Symbol unavailable in other modules)  ");
                break;
            case STV_PROTECTED:
                printf("protected (Not preemptible, not exported)        ");
                break;
        }
        char * address;
        if ( ELF64_ST_TYPE(sym_tbl[i].st_info) == STT_FUNC)
        {
            address = sym_tbl[i].st_value+mappingb+align;
            printf("address: %014p\t", address);
        }
        else
        {
            address = sym_tbl[i].st_value+mappingb;
            printf("address: %014p\t", address);
        }
        if ( address > mappingb && address < mappingb_end ) test(address);
        else printf("value: %15s\t", "invalid range");
        printf("type: ");
        switch (ELF64_ST_TYPE(sym_tbl[i].st_info)) {
            case STT_NOTYPE:
                printf("NOTYPE   (Symbol type is unspecified)             ");
                break;
            case STT_OBJECT:
                printf("OBJECT   (Symbol is a data object)                ");
                break;
                case STT_FUNC:
                printf("FUNCTION (Symbol is a code object)                ");
                break;
                case STT_SECTION:
                printf("SECTION  (Symbol associated with a section)       ");
                break;
                case STT_FILE:
                printf("FILE     (Symbol's name is file name)             ");
                break;
                case STT_COMMON:
                printf("COMMON   (Symbol is a common data object)         ");
                break;
                case STT_TLS:
                printf("TLS      (Symbol is thread-local data object)     ");
                break;
            default:
                printf("UNKNOWN  (%d)                                     ", ELF64_ST_TYPE(sym_tbl[i].st_info));
                break;
        }
        printf("name: [Not obtained due to it may crash this program]\n");
//         printf("\n");
    }
}

void print_elf_symbol_table_lookup_got_and_plt(char * arrayc, Elf64_Ehdr * eh, Elf64_Shdr sh_table[], uint64_t symbol_table)
{
    int level = 3;
        switch(sh_table[symbol_table].sh_type) {
            case SHT_NULL:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_PROGBITS:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_SYMTAB:
                symbol(arrayc, sh_table, symbol_table);
                break;
            case SHT_STRTAB:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_RELA:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_HASH:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_DYNAMIC:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_NOTE:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_NOBITS:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_REL:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_SHLIB:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_DYNSYM:
                symbol(arrayc, sh_table, symbol_table);
                break;
            case SHT_INIT_ARRAY:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_FINI_ARRAY:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_PREINIT_ARRAY:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_GROUP:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_SYMTAB_SHNDX:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_NUM:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOOS:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_ATTRIBUTES:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_HASH:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_LIBLIST:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_CHECKSUM:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOSUNW:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_SUNW_COMDAT:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_SUNW_syminfo:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_verdef:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_verneed:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_GNU_versym:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOPROC:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_HIPROC:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_LOUSER:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            case SHT_HIUSER:
                if (level == 3) relocation_got_and_plt(arrayc, sh_table, symbol_table);
                break;
            default:
                printf("UNKNOWN ");
                break;
        }
}

char * print_symbols_lookup_got_and_ptl(char * arrayd, Elf64_Ehdr * eh, Elf64_Shdr sh_table[], int index)
{
//     for(int i=0; i<eh->e_shnum; i++) {
        printf("print_symbols_lookup: trying index %d\n", 10);
        print_elf_symbol_table_lookup_got_and_plt(arrayd, eh, sh_table, 10);
        printf("print_symbols_lookup: trying index %d\n", 11);
        print_elf_symbol_table_lookup_got_and_plt(arrayd, eh, sh_table, 11);
//     }
}

void * lookup_symbol_by_name(const char * arrayb, Elf64_Ehdr * eh, char * name) {

        read_section_header_table_(arrayb, eh, &_elf_symbol_table);
        char * symbol = print_symbols_lookup_name(arrayb, eh, _elf_symbol_table, name);
        return symbol;
}

void * lookup_symbol_by_name_(const char * lib, const char * name) {
        const char * arrayb = init(lib);
        map();
        Elf64_Ehdr * eh = (Elf64_Ehdr *) arrayb;
        Elf64_Shdr *_elf_symbol_tableb;
        if(!strncmp((char*)eh->e_ident, "\177ELF", 4)) {
            if ( read_section_header_table_(arrayb, eh, &_elf_symbol_tableb) == 0) {
                char * symbol = print_symbols_lookup_name(arrayb, eh, _elf_symbol_tableb, name);
                return symbol;
            }
        }
        else abort_();
}

void * lookup_symbol_by_index(const char * arrayb, Elf64_Ehdr * eh, int symbol_index) {
        printf("attempting to look up symbol, index = %d\n", symbol_index);

        read_section_header_table_(arrayb, eh, &_elf_symbol_table);
//         nl();
//         nl();
//         print_symbols_lookup_got_and_ptl(arrayb, eh, _elf_symbol_table, symbol_index);
//         nl();
//         nl();
        char * GOT = lookup_symbol_by_name_("./test_lib.so", "_GLOBAL_OFFSET_TABLE_");
        printf("address of GOT = %014p\n", GOT);
        nl();
        nl();
        char * symbol = print_symbols_lookup(arrayb, eh, _elf_symbol_table, symbol_index);
        printf("symbol = %d (%014p)\n", symbol, symbol);
        return symbol;
}

ElfW(Word)
get_dynamic_entry(ElfW(Dyn) *dynamic, int field)
{
    printf("called get_dynamic_entry\n");

// Name        Value       d_un        Executable      Shared Object
// DT_NULL     0           ignored     mandatory       mandatory
// DT_NEEDED   1           d_val       optional        optional
// DT_PLTRELSZ 2           d_val       optional        optional
// DT_PLTGOT   3           d_ptr       optional        optional
// DT_HASH     4           d_ptr       mandatory       mandatory
// DT_STRTAB   5           d_ptr       mandatory       mandatory
// DT_SYMTAB   6           d_ptr       mandatory       mandatory
// DT_RELA     7           d_ptr       mandatory       optional
// DT_RELASZ   8           d_val       mandatory       optional
// DT_RELAENT  9           d_val       mandatory       optional
// DT_STRSZ    10          d_val       mandatory       mandatory
// DT_SYMENT   11          d_val       mandatory       mandatory
// DT_INIT     12          d_ptr       optional        optional
// DT_FINI     13          d_ptr       optional        optional
// DT_SONAME   14          d_val       ignored         optional
// DT_RPATH    15          d_val       optional        ignored
// DT_SYMBOLIC 16          ignored     ignored         optional
// DT_REL      17          d_ptr       mandatory       optional
// DT_RELSZ    18          d_val       mandatory       optional
// DT_RELENT   19          d_val       mandatory       optional
// DT_PLTREL   20          d_val       optional        optional
// DT_DEBUG    21          d_ptr       optional        ignored
// DT_TEXTREL  22          ignored     optional        optional
// DT_JMPREL   23          d_ptr       optional        optional
// DT_BIND_NOW 24          ignored     optional        optional
// DT_LOPROC   0x70000000  unspecified unspecified     unspecified
// DT_HIPROC   0x7fffffff  unspecified unspecified     unspecified
// 
// DT_NULL         An entry with a DT_NULL tag marks the end of the _DYNAMIC array.
// DT_NEEDED       This element holds the string table offset of a null-terminated string, giving
//                 the name of a needed library. The offset is an index into the table recorded
//                 in the DT_STRTAB entry. See "Shared Object Dependencies'' for more
//                 information about these names. The dynamic array may contain multiple
//                 entries with this type. These entries' relative order is significant, though
//                 their relation to entries of other types is not.
// 
// DT_PLTRELSZ     This element holds the total size, in bytes, of the relocation entries
//                 associated with the procedure linkage table. If an entry of type DT_JMPREL
//                 is present, a DT_PLTRELSZ must accompany it.
// 
// DT_PLTGOT       This element holds an address associated with the procedure linkage table
//                 and/or the global offset table.
// 
// DT_HASH         This element holds the address of the symbol hash table, described in "Hash
//                 Table". This hash table refers to the symbol table referenced by the
//                 DT_SYMTAB element.
// 
// DT_STRTAB       This element holds the address of the string table, described in Chapter 1.
//                 Symbol names, library names, and other strings reside in this table.
// 
// DT_SYMTAB       This element holds the address of the symbol table, described in
//                 Chapter 1, with Elf32_Sym entries for the 32-bit class of files.
// 
// DT_RELA         This element holds the address of a relocation table, described in
//                 Chapter 1. Entries in the table have explicit addends, such as Elf32_Rela
//                 for the 32-bit file class. An object file may have multiple relocation
//                 sections. When building the relocation table for an executable or shared
//                 object file, the link editor catenates those sections to form a single table.
//                 Although the sections remain independent in the object file, the dynamic
//                 linker sees a single table. When the dynamic linker creates the process
//                 image for an executable file or adds a shared object to the process image,
//                 it reads the relocation table and performs the associated actions. If this
//                 element is present, the dynamic structure must also have DT_RELASZ and
//                 DT_RELAENT elements. When relocation is "mandatory" for a file, either
//                 DT_RELA or DT_REL may occur (both are permitted but not required).
// 
// DT_RELASZ       This element holds the total size, in bytes, of the DT_RELA relocation table.
// 
// DT_RELAENT      This element holds the size, in bytes, of the DT_RELA relocation entry.
// 
// DT_STRSZ        This element holds the size, in bytes, of the string table.
// 
// DT_SYMENT       This element holds the size, in bytes, of a symbol table entry.
// 
// DT_INIT         This element holds the address of the initialization function, discussed in
//                 "Initialization and Termination Functions" below.
// 
// DT_FINI         This element holds the address of the termination function, discussed in
//                 "Initialization and Termination Functions" below.
// 
// DT_SONAME       This element holds the string table offset of a null-terminated string, giving
//                 the name of the shared object. The offset is an index into the table recorded
//                 in the DT_STRTAB entry. See "Shared Object Dependencies" below for
//                 more information about these names.
// 
// DT_RPATH        This element holds the string table offset of a null-terminated search library
//                 search path string, discussed in "Shared Object Dependencies". The offset
//                 is an index into the table recorded in the DT_STRTAB entry.
// 
// DT_SYMBOLIC     This element's presence in a shared object library alters the dynamic linker's
//                 symbol resolution algorithm for references within the library. Instead of
//                 starting a symbol search with the executable file, the dynamic linker starts
//                 from the shared object itself. If the shared object fails to supply the
//                 referenced symbol, the dynamic linker then searches the executable file and
//                 other shared objects as usual.
// 
// DT_REL          This element is similar to DT_RELA, except its table has implicit addends,
//                 such as Elf32_Rel for the 32-bit file class. If this element is present, the
//                 dynamic structure must also have DT_RELSZ and DT_RELENT elements.
// 
// DT_RELSZ        This element holds the total size, in bytes, of the DT_REL relocation table.
// 
// DT_RELENT       This element holds the size, in bytes, of the DT_REL relocation entry.
// 
// DT_PLTREL       This member specifies the type of relocation entry to which the procedure
//                 linkage table refers. The d_val member holds DT_REL or DT_RELA , as
//                 appropriate. All relocations in a procedure linkage table must use the same
//                 relocation.
// 
// DT_DEBUG        This member is used for debugging. Its contents are not specified in this
//                 document.
// 
// DT_TEXTREL      This member's absence signifies that no relocation entry should cause a
//                 modification to a non-writable segment, as specified by the segment
//                 permissions in the program header table. If this member is present, one or
//                 more relocation entries might request modifications to a non-writable
//                 segment, and the dynamic linker can prepare accordingly.
// 
// DT_JMPREL       If present, this entries d_ptr member holds the address of relocation
//                 entries associated solely with the procedure linkage table. Separating these
//                 relocation entries lets the dynamic linker ignore them during process
//                 initialization, if lazy binding is enabled. If this entry is present, the related
//                 entries of types DT_PLTRELSZ and DT_PLTREL must also be present.
// 
// DT_BIND_NOW     If present in a shared object or executable, this entry instructs the dynamic
//                 linker to process all relocations for the object containing this entry before
//                 transferring control to the program. The presence of this entry takes
//                 precedence over a directive to use lazy binding for this object when
//                 specified through the environment or via dlopen( BA_LIB).
// 
// DT_LOPROC through DT_HIPROC
//                 Values in this inclusive range are reserved for processor-specific semantics.
//                 If meanings are specified, the processor supplement explains them.
// 
// Except for the DT_NULL element at the end of the array, and the relative order of DT_NEEDED
// elements, entries may appear in any order. Tag values not appearing in the table are reserved.


    for (; dynamic->d_tag != DT_NULL; dynamic++) {
        printf("testing if ");
/* Legal values for d_tag (dynamic entry type).  */

// #define DT_NULL		0		/* Marks end of dynamic section */
// #define DT_NEEDED	1		/* Name of needed library */
// #define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
// #define DT_PLTGOT	3		/* Processor defined value */
// #define DT_HASH		4		/* Address of symbol hash table */
// #define DT_STRTAB	5		/* Address of string table */
// #define DT_SYMTAB	6		/* Address of symbol table */
// #define DT_RELA		7		/* Address of Rela relocs */
// #define DT_RELASZ	8		/* Total size of Rela relocs */
// #define DT_RELAENT	9		/* Size of one Rela reloc */
// #define DT_STRSZ	10		/* Size of string table */
// #define DT_SYMENT	11		/* Size of one symbol table entry */
// #define DT_INIT		12		/* Address of init function */
// #define DT_FINI		13		/* Address of termination function */
// #define DT_SONAME	14		/* Name of shared object */
// #define DT_RPATH	15		/* Library search path (deprecated) */
// #define DT_SYMBOLIC	16		/* Start symbol search here */
// #define DT_REL		17		/* Address of Rel relocs */
// #define DT_RELSZ	18		/* Total size of Rel relocs */
// #define DT_RELENT	19		/* Size of one Rel reloc */
// #define DT_PLTREL	20		/* Type of reloc in PLT */
// #define DT_DEBUG	21		/* For debugging; unspecified */
// #define DT_TEXTREL	22		/* Reloc might modify .text */
// #define DT_JMPREL	23		/* Address of PLT relocs */
// #define	DT_BIND_NOW	24		/* Process relocations of object */
// #define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
// #define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
// #define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
// #define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
// #define DT_RUNPATH	29		/* Library search path */
// #define DT_FLAGS	30		/* Flags for the object being loaded */
// #define DT_ENCODING	32		/* Start of encoded range */
// #define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
// #define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
// #define	DT_NUM		34		/* Number used */
// #define DT_LOOS		0x6000000d	/* Start of OS-specific */
// #define DT_HIOS		0x6ffff000	/* End of OS-specific */
// #define DT_LOPROC	0x70000000	/* Start of processor-specific */
// #define DT_HIPROC	0x7fffffff	/* End of processor-specific */
// #define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
        switch (dynamic->d_tag) {
            case DT_NULL:
                printf("DT_NULL");
                break;
            case DT_NEEDED:
                printf("DT_NEEDED");
                break;
            case DT_PLTRELSZ:
                printf("DT_PLTRELSZ");
                break;
            case DT_PLTGOT:
                printf("DT_PLTGOT");
                break;
            case DT_HASH:
                printf("DT_HASH");
                break;
            case DT_STRTAB:
                printf("DT_STRTAB");
                break;
            case DT_SYMTAB:
                printf("DT_SYMTAB");
                break;
            case DT_RELA:
                printf("DT_RELA");
                break;
            case DT_RELASZ:
                printf("DT_RELASZ");
                break;
            case DT_RELAENT:
                printf("DT_RELAENT");
                break;
            case DT_STRSZ:
                printf("DT_STRSZ");
                break;
            case DT_SYMENT:
                printf("DT_SYMENT");
                break;
            case DT_INIT:
                printf("DT_INIT");
                break;
            case DT_FINI:
                printf("DT_FINI");
                break;
            case DT_SONAME:
                printf("DT_SONAME");
                break;
            case DT_RPATH:
                printf("DT_RPATH");
                break;
            case DT_SYMBOLIC:
                printf("DT_SYMBOLIC");
                break;
            case DT_REL:
                printf("DT_REL");
                break;
            case DT_RELSZ:
                printf("DT_RELSZ");
                break;
            case DT_RELENT:
                printf("DT_RELENT");
                break;
            case DT_PLTREL:
                printf("DT_PLTREL");
                break;
            case DT_DEBUG:
                printf("DT_DEBUG");
                break;
            case DT_TEXTREL:
                printf("DT_TEXTREL");
                break;
            case DT_JMPREL:
                printf("DT_JMPREL");
                break;
            case DT_BIND_NOW:
                printf("DT_BIND_NOW");
                break;
            case DT_INIT_ARRAY:
                printf("DT_INIT_ARRAY");
                break;
            case DT_FINI_ARRAY:
                printf("DT_FINI_ARRAY");
                break;
            case DT_INIT_ARRAYSZ:
                printf("DT_INIT_ARRAYSZ");
                break;
            case DT_FINI_ARRAYSZ:
                printf("DT_FINI_ARRAYSZ");
                break;
            case DT_RUNPATH:
                printf("DT_RUNPATH");
                break;
            case DT_FLAGS:
                printf("DT_FLAGS");
                break;
            case DT_ENCODING:
                printf("DT_ENCODING (or DT_PREINIT_ARRAY)");
                break;
            case DT_PREINIT_ARRAYSZ:
                printf("DT_PREINIT_ARRAYSZ");
                break;
            case DT_NUM:
                printf("DT_NUM");
                break;
            case DT_LOOS:
                printf("DT_LOOS");
                break;
            case DT_HIOS:
                printf("DT_HIOS");
                break;
            case DT_LOPROC:
                printf("DT_LOPROC");
                break;
            case DT_HIPROC:
                printf("DT_HIPROC (or DT_FILTER)");
                break;
            case DT_PROCNUM:
                printf("DT_PROCNUM");
                break;
            case DT_VERSYM:
                printf("DT_VERSYM");
                break;
            case DT_RELACOUNT:
                printf("DT_RELACOUNT");
                break;
            case DT_RELCOUNT:
                printf("DT_RELCOUNT");
                break;
            case DT_FLAGS_1:
                printf("DT_FLAGS_1");
                break;
            case DT_VERDEF:
                printf("DT_VERDEF");
                break;
            case DT_VERDEFNUM:
                printf("DT_VERDEFNUM");
                break;
            case DT_VERNEED:
                printf("DT_VERNEED");
                break;
            case DT_VERNEEDNUM:
                printf("DT_VERNEEDNUM");
                break;
            case DT_AUXILIARY:
                printf("DT_AUXILIARY");
                break;
            default:
                printf("%d", dynamic->d_tag);
                break;
        }
        printf(" == ");
        switch (field) {
            case DT_NULL:
                printf("DT_NULL");
                break;
            case DT_NEEDED:
                printf("DT_NEEDED");
                break;
            case DT_PLTRELSZ:
                printf("DT_PLTRELSZ");
                break;
            case DT_PLTGOT:
                printf("DT_PLTGOT");
                break;
            case DT_HASH:
                printf("DT_HASH");
                break;
            case DT_STRTAB:
                printf("DT_STRTAB");
                break;
            case DT_SYMTAB:
                printf("DT_SYMTAB");
                break;
            case DT_RELA:
                printf("DT_RELA");
                break;
            case DT_RELASZ:
                printf("DT_RELASZ");
                break;
            case DT_RELAENT:
                printf("DT_RELAENT");
                break;
            case DT_STRSZ:
                printf("DT_STRSZ");
                break;
            case DT_SYMENT:
                printf("DT_SYMENT");
                break;
            case DT_INIT:
                printf("DT_INIT");
                break;
            case DT_FINI:
                printf("DT_FINI");
                break;
            case DT_SONAME:
                printf("DT_SONAME");
                break;
            case DT_RPATH:
                printf("DT_RPATH");
                break;
            case DT_SYMBOLIC:
                printf("DT_SYMBOLIC");
                break;
            case DT_REL:
                printf("DT_REL");
                break;
            case DT_RELSZ:
                printf("DT_RELSZ");
                break;
            case DT_RELENT:
                printf("DT_RELENT");
                break;
            case DT_PLTREL:
                printf("DT_PLTREL");
                break;
            case DT_DEBUG:
                printf("DT_DEBUG");
                break;
            case DT_TEXTREL:
                printf("DT_TEXTREL");
                break;
            case DT_JMPREL:
                printf("DT_JMPREL");
                break;
            case DT_BIND_NOW:
                printf("DT_BIND_NOW");
                break;
            case DT_INIT_ARRAY:
                printf("DT_INIT_ARRAY");
                break;
            case DT_FINI_ARRAY:
                printf("DT_FINI_ARRAY");
                break;
            case DT_INIT_ARRAYSZ:
                printf("DT_INIT_ARRAYSZ");
                break;
            case DT_FINI_ARRAYSZ:
                printf("DT_FINI_ARRAYSZ");
                break;
            case DT_RUNPATH:
                printf("DT_RUNPATH");
                break;
            case DT_FLAGS:
                printf("DT_FLAGS");
                break;
            case DT_ENCODING:
                printf("DT_ENCODING (or DT_PREINIT_ARRAY)");
                break;
            case DT_PREINIT_ARRAYSZ:
                printf("DT_PREINIT_ARRAYSZ");
                break;
            case DT_NUM:
                printf("DT_NUM");
                break;
            case DT_LOOS:
                printf("DT_LOOS");
                break;
            case DT_HIOS:
                printf("DT_HIOS");
                break;
            case DT_LOPROC:
                printf("DT_LOPROC");
                break;
            case DT_HIPROC:
                printf("DT_HIPROC (or DT_FILTER)");
                break;
            case DT_PROCNUM:
                printf("DT_PROCNUM");
                break;
            case DT_VERSYM:
                printf("DT_VERSYM");
                break;
            case DT_RELACOUNT:
                printf("DT_RELACOUNT");
                break;
            case DT_RELCOUNT:
                printf("DT_RELCOUNT");
                break;
            case DT_FLAGS_1:
                printf("DT_FLAGS_1");
                break;
            case DT_VERDEF:
                printf("DT_VERDEF");
                break;
            case DT_VERDEFNUM:
                printf("DT_VERDEFNUM");
                break;
            case DT_VERNEED:
                printf("DT_VERNEED");
                break;
            case DT_VERNEEDNUM:
                printf("DT_VERNEEDNUM");
                break;
            case DT_AUXILIARY:
                printf("DT_AUXILIARY");
                break;
            default:
                printf("%d (unknown)", field);
                break;
        }
        printf("\n");
        if (dynamic->d_tag == field) {
            printf("returning %p\n", dynamic->d_un.d_val);
            return dynamic->d_un.d_val;
        }
    }
    printf("returning 0\n");
    return 0;
}

static int flags_to_prot(const int p_flags)
{
    printf("called prot_from_phdr\n");
    int prot = 0;
    if (p_flags & PF_R)
        prot |= PROT_READ;
    if (p_flags & PF_W)
        prot |= PROT_WRITE;
    if (p_flags & PF_X)
        prot |= PROT_EXEC;
    return prot;
}

int
readelf_(const char * filename) {
    setlocale(LC_NUMERIC, "en_US.utf-8"); /* important */
    array = init(filename);
        Elf64_Ehdr * _elf_header = (Elf64_Ehdr *) array;
        read_section_header_table_(array, _elf_header, &_elf_symbol_table);
        if(!strncmp((char*)_elf_header->e_ident, "\177ELF", 4)) {
//                 ELF Header:
//                 Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
//                 Class:                             ELF64
//                 Data:                              2's complement, little endian
//                 Version:                           1 (current)
//                 OS/ABI:                            UNIX - System V
//                 ABI Version:                       0
//                 Type:                              EXEC (Executable file)
//                 Machine:                           Advanced Micro Devices X86-64
//                 Version:                           0x1
//                 Entry point address:               0x400820
//                 Start of program headers:          64 (bytes into file)
//                 Start of section headers:          11408 (bytes into file)
//                 Flags:                             0x0
//                 Size of this header:               64 (bytes)
//                 Size of program headers:           56 (bytes)
//                 Number of program headers:         9
//                 Size of section headers:           64 (bytes)
//                 Number of section headers:         30
//                 Section header string table index: 29
//
            printf("Name:\t\t %s\n", filename);
            printf("ELF Identifier\t %s (", _elf_header->e_ident);
            __print_quoted_string__(_elf_header->e_ident, sizeof(_elf_header->e_ident), QUOTE_FORCE_HEX|QUOTE_OMIT_LEADING_TRAILING_QUOTES, "print");
            printf(" )\n");

            printf("Architecture\t ");
            switch(_elf_header->e_ident[EI_CLASS])
            {
                case ELFCLASSNONE:
                    printf("None\n");
                    break;

                case ELFCLASS32:
                    printf("32-bit\n");
                    break;

                case ELFCLASS64:
                    printf("64-bit\n");
                    break;
                    
                case ELFCLASSNUM:
                    printf("NUM ( unspecified )\n");
                    break;

                default:
                    printf("Unknown CLASS\n");
                    break;
            }

            printf("Data Type\t ");
            switch(_elf_header->e_ident[EI_DATA])
            {
                case ELFDATANONE:
                    printf("None\n");
                    break;

                case ELFDATA2LSB:
                    printf("2's complement, little endian\n");
                    break;

                case ELFDATA2MSB:
                    printf("2's complement, big endian\n");
                    break;
                    
                case ELFDATANUM:
                    printf("NUM ( unspecified )\n");
                    break;

                default:
                    printf("Unknown \n");
                    break;
            }

            printf("Version\t\t ");
            switch(_elf_header->e_ident[EI_VERSION])
            {
                case EV_NONE:
                    printf("None\n");
                    break;

                case EV_CURRENT:
                    printf("Current\n");
                    break;

                case EV_NUM:
                    printf("NUM ( Unspecified )\n");
                    break;

                default:
                    printf("Unknown \n");
                    break;
            }

            printf("OS ABI\t\t ");
            switch(_elf_header->e_ident[EI_OSABI])
            {
                case ELFOSABI_NONE:
                    printf("UNIX System V ABI\n");
                    break;

//                     case ELFOSABI_SYSV:
//                         printf("SYSV\n");
//                         break;
// 
                case ELFOSABI_HPUX:
                    printf("HP-UX\n");
                    break;

                case ELFOSABI_NETBSD:
                    printf("NetBSD\n");
                    break;

                case ELFOSABI_GNU:
                    printf("GNU\n");
                    break;

//                     case ELFOSABI_LINUX:
//                         printf("Linux\n");
//                         break;
// 
                case ELFOSABI_SOLARIS:
                    printf("Sun Solaris\n");
                    break;

                case ELFOSABI_AIX:
                    printf("ABM AIX\n");
                    break;

                case ELFOSABI_FREEBSD:
                    printf("FreeBSD\n");
                    break;

                case ELFOSABI_TRU64:
                    printf("Compaq Tru64\n");
                    break;

                case ELFOSABI_MODESTO:
                    printf("Novell Modesto\n");
                    break;

                case ELFOSABI_OPENBSD:
                    printf("OpenBSD\n");
                    break;

                case ELFOSABI_ARM_AEABI:
                    printf("ARM EABI\n");
                    break;

                case ELFOSABI_ARM:
                    printf("ARM\n");
                    break;

                case ELFOSABI_STANDALONE:
                    printf("Standalone (embedded) application\n");
                    break;

                default:
                    printf("Unknown \n");
                    break;
            }

            printf("File Type\t ");
            switch(_elf_header->e_type)
            {
                case ET_NONE:
                    printf("None\n");
                    break;

                case ET_REL:
                    printf("Relocatable file\n");
                    break;

                case ET_EXEC:
                    printf("Executable file\n");
                    break;

                case ET_DYN:
                    printf("Shared object file\n");
                    break;

                case ET_CORE:
                    printf("Core file\n");
                    break;

                case ET_NUM:
                    printf("Number of defined types\n");
                    break;

                case ET_LOOS:
                    printf("OS-specific range start\n");
                    break;

                case ET_HIOS:
                    printf("OS-specific range end\n");
                    break;

                case ET_LOPROC:
                    printf("Processor-specific range start\n");
                    break;

                case ET_HIPROC:
                    printf("Processor-specific range end\n");
                    break;

                default:
                    printf("Unknown \n");
                    break;
            }

            printf("Machine\t\t ");
            switch(_elf_header->e_machine)
            {
                case EM_NONE:
                    printf("None\n");
                    break;

                case EM_386:
                        printf("INTEL x86\n");
                        break;

                case EM_X86_64:
                        printf("AMD x86-64 architecture\n");
                        break;

                case EM_ARM:
                        printf("ARM\n");
                        break;
                default:
                        printf("Unknown\n");
                break;
            }
            
            /* Entry point */
            int entry=_elf_header->e_entry;
            printf("Entry point\t %014p\n", _elf_header->e_entry);
            

            /* ELF header size in bytes */
            printf("ELF header size\t %014p\n", _elf_header->e_ehsize);

            /* Program Header */
            printf("Program Header\t %014p (%d entries with a total of %d bytes)\n",
            _elf_header->e_phoff,
            _elf_header->e_phnum,
            _elf_header->e_phentsize
            );
            map();
// continue analysis
            for (int i = 0; i < _elf_header->e_phnum; ++i) {
                char * section_;
                printf("p_type:\t\t\t/* Segment type */\t\t= ");
                switch(_elf_program_header[i].p_type)
                {
                    case PT_NULL:
                        printf("PT_NULL\t\t/* Program header table entry unused */\n");
                        section_="PT_NULL";
                        break;
                    case PT_LOAD:
                        printf("PT_LOAD\t\t/* Loadable program segment */\n");
                        section_="PT_LOAD";
                        break;
                    case PT_DYNAMIC:
                        printf("PT_DYNAMIC\t\t/* Dynamic linking information */\n");
                        section_="PT_DYNAMIC";
                        PT_DYNAMIC_=i;
                        break;
                    case PT_INTERP:
                        printf("PT_INTERP\t\t/* Program interpreter */\n");
                        section_="PT_INTERP";
                        break;
                    case PT_NOTE:
                        printf("PT_NOTE\t\t/* Auxiliary information */\n");
                        section_="PT_NOTE";
                        break;
                    case PT_SHLIB:
                        printf("PT_SHLIB\t\t/* Reserved */\n");
                        section_="PT_SHLIB";
                        break;
                    case PT_PHDR:
                        printf("PT_PHDR\t\t/* Entry for header table itself */\n");
                        section_="PT_PHDR";
                        break;
                    case PT_TLS:
                        printf("PT_TLS\t\t/* Thread-local storage segment */\n");
                        section_="PT_TLS";
                        break;
                    case PT_NUM:
                        printf("PT_NUM\t\t/* Number of defined types */\n");
                        section_="PT_NUM";
                        break;
                    case PT_LOOS:
                        printf("PT_LOOS\t\t/* Start of OS-specific */\n");
                        section_="PT_LOOS";
                        break;
                    case PT_GNU_EH_FRAME:
                        printf("PT_GNU_EH_FRAME\t/* GCC .eh_frame_hdr segment */\n");
                        section_="PT_GNU_EH_FRAME";
                        break;
                    case PT_GNU_STACK:
                        printf("PT_GNU_STACK\t\t/* Indicates stack executability */\n");
                        section_="PT_GNU_STACK";
                        break;
                    case PT_GNU_RELRO:
                        printf("PT_GNU_RELRO\t\t/* Read-only after relocation */\n");
                        section_="PT_GNU_RELRO";
                        break;
                    case PT_SUNWBSS:
                        printf("PT_SUNWBSS\t\t/* Sun Specific segment */\n");
                        section_="PT_SUNWBSS";
                        break;
                    case PT_SUNWSTACK:
                        printf("PT_SUNWSTACK\t\t/* Stack segment */\n");
                        section_="PT_SUNWSTACK";
                        break;
                    case PT_HIOS:
                        printf("PT_HIOS\t\t/* End of OS-specific */\n");
                        section_="PT_HIOS";
                        break;
                    case PT_LOPROC:
                        printf("PT_LOPROC\t\t/* Start of processor-specific */\n");
                        section_="PT_LOPROC";
                        break;
                    case PT_HIPROC:
                        printf("PT_HIPROC\t\t/* End of processor-specific */\n");
                        section_="PT_HIPROC";
                        break;
                    default:
                        printf("Unknown\n");
                        section_="Unknown";
                        break;
                }
                if (section_ == "PT_DYNAMIC")
                {
                    // obtain PT_DYNAMIC into seperate array for use later
                    read_fast_verify(array, len, &tmp99D, (_elf_program_header[i].p_memsz + _elf_program_header[i].p_offset));
                    __lseek_string__(&tmp99D, _elf_program_header[i].p_memsz, _elf_program_header[i].p_offset);
                }
                char * tmp99;/* = malloc((_elf_program_header[i].p_memsz + _elf_program_header[i].p_offset));*/
                printf("ATTEMPING TO READ\n");
                printf("reading                %014p\n", (_elf_program_header[i].p_memsz + _elf_program_header[i].p_offset));
                read_fast_verify(array, len, &tmp99, (_elf_program_header[i].p_memsz + _elf_program_header[i].p_offset));
                printf("correcting position by %014p\n", _elf_program_header[i].p_offset);
                __lseek_string__(&tmp99, _elf_program_header[i].p_memsz, _elf_program_header[i].p_offset);
                printf("reading                %d\n", _elf_program_header[i].p_memsz);
                __print_quoted_string__(tmp99, _elf_program_header[i].p_memsz, 0, "print");
                printf("\nREAD\n");
                printf("p_flags:\t\t/* Segment flags */\t\t= %014p\np_offset:\t\t/* Segment file offset */\t= %014p\np_vaddr:\t\t/* Segment virtual address */\t= %014p\np_paddr:\t\t/* Segment physical address */\t= %014p\np_filesz:\t\t/* Segment size in file */\t= %014p\np_memsz:\t\t/* Segment size in memory */\t= %014p\np_align:\t\t/* Segment alignment */\t\t= %014p\n\n\n", _elf_program_header[i].p_flags, _elf_program_header[i].p_offset, _elf_program_header[i].p_vaddr+mappingb, _elf_program_header[i].p_paddr, _elf_program_header[i].p_filesz, _elf_program_header[i].p_memsz, _elf_program_header[i].p_align);
                nl();
                printf("\t\tp_flags: %014p", _elf_program_header[i].p_flags);
                printf(" p_offset: %014p", _elf_program_header[i].p_offset);
                printf(" p_vaddr:  %014p", _elf_program_header[i].p_vaddr+mappingb);
                printf(" p_paddr: %014p", _elf_program_header[i].p_paddr);
                printf(" p_filesz: %014p", _elf_program_header[i].p_filesz);
                printf(" p_memsz: %014p", _elf_program_header[i].p_memsz);
                printf(" p_align: %014p\n", _elf_program_header[i].p_align);
            }

            if (PT_DYNAMIC_ != 0) {
// A PT_DYNAMIC program header element points at the .dynamic section, explained in
// "Dynamic Section" below. The .got and .plt sections also hold information related to
// position-independent code and dynamic linking. Although the .plt appears in a text segment
// above, it may reside in a text or a data segment, depending on the processor.
// 
// As "Sections" describes, the .bss section has the type SHT_NOBITS. Although it occupies no
// space in the file, it contributes to the segment's memory image. Normally, these uninitialized
// data reside at the end of the segment, thereby making p_memsz larger than p_filesz.
// 

                printf("PT_LOAD 1 = \n");
                printf("p_flags:\t\t/* Segment flags */\t\t= %014p\np_offset:\t\t/* Segment file offset */\t= %014p\np_vaddr:\t\t/* Segment virtual address */\t= %014p\np_paddr:\t\t/* Segment physical address */\t= %014p\np_filesz:\t\t/* Segment size in file */\t= %014p\np_memsz:\t\t/* Segment size in memory */\t= %014p\np_align:\t\t/* Segment alignment */\t\t= %014p\n\n\n", _elf_program_header[First_Load_Header_index].p_flags, _elf_program_header[First_Load_Header_index].p_offset, _elf_program_header[First_Load_Header_index].p_vaddr+mappingb, _elf_program_header[First_Load_Header_index].p_paddr, _elf_program_header[First_Load_Header_index].p_filesz, _elf_program_header[First_Load_Header_index].p_memsz, _elf_program_header[First_Load_Header_index].p_align);
                printf("PT_LOAD 2 = \n");
                printf("p_flags:\t\t/* Segment flags */\t\t= %014p\np_offset:\t\t/* Segment file offset */\t= %014p\np_vaddr:\t\t/* Segment virtual address */\t= %014p\np_paddr:\t\t/* Segment physical address */\t= %014p\np_filesz:\t\t/* Segment size in file */\t= %014p\np_memsz:\t\t/* Segment size in memory */\t= %014p\np_align:\t\t/* Segment alignment */\t\t= %014p\n\n\n", _elf_program_header[Last_Load_Header_index].p_flags, _elf_program_header[Last_Load_Header_index].p_offset, _elf_program_header[Last_Load_Header_index].p_vaddr+mappingb, _elf_program_header[Last_Load_Header_index].p_paddr, _elf_program_header[Last_Load_Header_index].p_filesz, _elf_program_header[Last_Load_Header_index].p_memsz, _elf_program_header[Last_Load_Header_index].p_align);
                printf("first PT_LOAD _elf_program_header[%d]->p_paddr = \n%014p\n", First_Load_Header_index, _elf_program_header[First_Load_Header_index].p_paddr+mappingb);
                printf("Second PT_LOAD _elf_program_header[%d]->p_paddr = \n%014p\n", Last_Load_Header_index, _elf_program_header[Last_Load_Header_index].p_paddr+mappingb);
                ElfW(Dyn) * dynamic = tmp99D;

/*

Relocation
Relocation Types
Relocation entries describe how to alter the following instruction and data fields (bit numbers
appear in the lower box corners).


        word32
31                  0

word32      This specifies a 32-bit field occupying 4 bytes with arbitrary byte alignment. These
            values use the same byte order as other word values in the Intel architecture.

                         3    2    1    0
0x01020304           01   02   03   04
                 31                     0

Calculations below assume the actions are transforming a relocatable file into either an
executable or a shared object file. Conceptually, the link editor merges one or more relocatable
files to form the output. It first decides how to combine and locate the input files, then updates
the symbol values, and finally performs the relocation. Relocations applied to executable or
shared object files are similar and accomplish the same result. Descriptions below use the
following notation.

A       This means the addend used to compute the value of the relocatable field.

B       This means the base address at which a shared object has been loaded into memory
        during execution. Generally, a shared object file is built with a 0 base virtual address,
        but the execution address will be different.

G       This means the offset into the global offset table at which the address of the
        relocation entry's symbol will reside during execution. See "Global Offset Table''
        below for more information.

GOT     This means the address of the global offset table. See "Global Offset Table'' below
        for more information.

L       This means the place (section offset or address) of the procedure linkage table entry
        for a symbol. A procedure linkage table entry redirects a function call to the proper
        destination. The link editor builds the initial procedure linkage table, and the
        dynamic linker modifies the entries during execution. See "Procedure Linkage
        Table'' below for more information.

P       This means the place (section offset or address) of the storage unit being relocated
        (computed using r_offset ).
        
S       This means the value of the symbol whose index resides in the relocation entry.

A relocation entry's r_offset value designates the offset or virtual address of the first byte
of the affected storage unit. The relocation type specifies which bits to change and how to
calculate their values. The Intel architecture uses only Elf32_Rel relocation entries, the field
to be relocated holds the addend. In all cases, the addend and the computed result use the same
byte order.

Name                Value       Field       Calculation
R_386_NONE          0           none        none
R_386_32            1           word32      S + A
R_386_PC32          2           word32      S + A - P
R_386_GOT32         3           word32      G + A
R_386_PLT32         4           word32      L + A - P
R_386_COPY          5           none        none
R_386_GLOB_DAT      6           word32      S
R_386_JMP_SLOT      7           word32      S
R_386_RELATIVE      8           word32      B + A
R_386_GOTOFF        9           word32      S + A - GOT
R_386_GOTPC         10          word32      GOT + A - P

Some relocation types have semantics beyond simple calculation.

R_386_GLOB_DAT      This relocation type is used to set a global offset table entry to the address
                    of the specified symbol. The special relocation type allows one to determine
                    the correspondence between symbols and global offset table entries.

R_386_JMP_SLOT      The link editor creates this relocation type for dynamic linking. Its offset
                    member gives the location of a procedure linkage table entry. The dynamic
                    linker modifies the procedure linkage table entry to transfer control to the
                    designated symbol's address [see "Procedure Linkage Table'' below].

R_386_RELATIVE      The link editor creates this relocation type for dynamic linking. Its offset
                    member gives a location within a shared object that contains a value
                    representing a relative address. The dynamic linker computes the
                    corresponding virtual address by adding the virtual address at which the
                    shared object was loaded to the relative address. Relocation entries for this
                    type must specify 0 for the symbol table index.

R_386_GOTOFF        This relocation type computes the difference between a symbol's value and
                    the address of the global offset table. It additionally instructs the link editor
                    to build the global offset table.
                    
R_386_GOTPC         This relocation type resembles R_386_PC32, except it uses the address
                    of the global offset table in its calculation. The symbol referenced in this
                    relocation normally is _GLOBAL_OFFSET_TABLE_, which additionally
                    instructs the link editor to build the global offset table.

*/

//                 printf("printing symbol data\n");
//                 Elf64_Sym *syms = mappingb + get_dynamic_entry(dynamic, DT_SYMTAB);
//                 symbol1(array, syms, 0);
                printf("examining current entries:\n");
                get_dynamic_entry(dynamic, -1);
                printf("printing relocation data\n");
                // needs to be the address of the mapping itself, not the base address
                Elf64_Rela *relocs = mappingb + get_dynamic_entry(dynamic, DT_RELA);
                printf("relocs = %p (%x)\n", relocs, relocs);
                size_t relocs_size = get_dynamic_entry(dynamic, DT_RELASZ);
                printf("relocs_size = %d\n", relocs_size);
                if (relocs == mappingb && relocs_size == 0) {} else {
                    for (int i = 0; i < relocs_size  / sizeof(Elf64_Rela); i++) {
                        Elf64_Rela *reloc = &relocs[i];
                        int reloc_type = ELF64_R_TYPE(reloc->r_info);
                        printf("i = %d,\t\tELF64_R_TYPE(reloc->r_info)\t= ", i);
                        switch (reloc_type) {
                            #if defined(__x86_64__)
                                
    // /* AMD x86-64 relocations.  */
    // #define R_X86_64_NONE		0	/* No reloc */
    // #define R_X86_64_64		1	/* Direct 64 bit  */
    // #define R_X86_64_PC32		2	/* PC relative 32 bit signed */
    // #define R_X86_64_GOT32		3	/* 32 bit GOT entry */
    // #define R_X86_64_PLT32		4	/* 32 bit PLT address */
    // #define R_X86_64_COPY		5	/* Copy symbol at runtime */
    // #define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
    // #define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
    // #define R_X86_64_RELATIVE	8	/* Adjust by program base */
    // #define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
    // 					   offset to GOT */
    // #define R_X86_64_32		10	/* Direct 32 bit zero extended */
    // #define R_X86_64_32S		11	/* Direct 32 bit sign extended */
    // #define R_X86_64_16		12	/* Direct 16 bit zero extended */
    // #define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
    // #define R_X86_64_8		14	/* Direct 8 bit sign extended  */
    // #define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
    // #define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
    // #define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
    // #define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
    // #define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
    // 					   to two GOT entries for GD symbol */
    // #define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
    // 					   to two GOT entries for LD symbol */
    // #define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
    // #define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
    // 					   to GOT entry for IE symbol */
    // #define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
    // #define R_X86_64_PC64		24	/* PC relative 64 bit */
    // #define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
    // #define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
    // 					   offset to GOT */
    // #define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
    // #define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
    // 					   to GOT entry */
    // #define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
    // #define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
    // #define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
    // 					   to PLT entry */
    // #define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
    // #define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
    // #define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
    // #define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
    // 					   descriptor.  */
    // #define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
    // #define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
    // #define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
    // 					/* 39 Reserved was R_X86_64_PC32_BND */
    // 					/* 40 Reserved was R_X86_64_PLT32_BND */
    // #define R_X86_64_GOTPCRELX	41	/* Load from 32 bit signed pc relative
    // 					   offset to GOT entry without REX
    // 					   prefix, relaxable.  */
    // #define R_X86_64_REX_GOTPCRELX	42	/* Load from 32 bit signed pc relative
    // 					   offset to GOT entry with REX prefix,
    // 					   relaxable.  */
    // #define R_X86_64_NUM		43

                            case R_X86_64_NONE:
                            {
                                printf("\n\n\nR_X86_64_NONE                calculation: none\n");
                                break;
                            }
                            case R_X86_64_64:
                            {
                                printf("\n\n\nR_X86_64_64                  calculation: S + A (symbol value + r_addend)\n");
                                printf("reloc->r_offset = %14p\n", reloc->r_offset);
                                *((char*)mappingb + reloc->r_offset) = lookup_symbol_by_index(array, _elf_header, ELF64_R_SYM(reloc->r_info)) + reloc->r_addend+mappingb;
                                printf("((char*)mappingb + reloc->r_offset)            = %014p\n", ((char*)mappingb + reloc->r_offset));
                                break;
                            }
                            case R_X86_64_PC32:
                            {
                                printf("\n\n\nR_X86_64_PC32                calculation: S + A - P (symbol value + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)\n");
                                printf("reloc->r_offset = %14p\n", reloc->r_offset);
                                *((char*)mappingb + reloc->r_offset) = lookup_symbol_by_index(array, _elf_header, ELF64_R_SYM(reloc->r_info)) + reloc->r_addend+mappingb;
                                printf("((char*)mappingb + reloc->r_offset)            = %014p\n", ((char*)mappingb + reloc->r_offset));
                                break;
                            }
                            case R_X86_64_GOT32:
                            {
                                printf("\n\n\nR_X86_64_GOT32               calculation: G + A (address of global offset table + r_addend)\n");
                                break;
                            }
                            case R_X86_64_PLT32:
                            {
                                printf("\n\n\nR_X86_64_PLT32               calculation: L + A - P ((L: This means the place (section offset or address) of the procedure linkage table entry for a symbol) + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).) \n");
                                break;
                            }
                            case R_X86_64_COPY:
                            {
                                printf("\n\n\nR_X86_64_COPY                calculation: none\n");
                                break;
                            }
                            case R_X86_64_GLOB_DAT:
                            {
                                printf("\n\n\nR_X86_64_GLOB_DAT            calculation: S (symbol value)\n");
                                *((char*)mappingb + reloc->r_offset) = lookup_symbol_by_index(array, _elf_header, ELF64_R_SYM(reloc->r_info))+mappingb;
                                printf("((char*)mappingb + reloc->r_offset)            = %014p\n", ((char*)mappingb + reloc->r_offset));
                                break;
                            }
                            case R_X86_64_JUMP_SLOT:
                            {
                                printf("\n\n\nR_X86_64_JUMP_SLOT           calculation: S (symbol value)\n");
                                *((char*)mappingb + reloc->r_offset) = lookup_symbol_by_index(array, _elf_header, ELF64_R_SYM(reloc->r_info))+mappingb;
                                printf("((char*)mappingb + reloc->r_offset)            = %014p\n", ((char*)mappingb + reloc->r_offset));
                                break;
                            }
                            case R_X86_64_RELATIVE:
                            {
                                printf("\n\n\nR_X86_64_RELATIVE            calculation: B + A (base address + r_addend)\n");
                                printf("mappingb    = %14p\n", mappingb);
                                printf("reloc->r_offset = %14p+%14p=%14p\n", mappingb, reloc->r_offset, mappingb+reloc->r_offset);
                                printf("reloc->r_addend = %14p\n", reloc->r_addend);
                                *((char*)mappingb + reloc->r_offset) = mappingb + reloc->r_addend;
                                printf("((char*)mappingb + reloc->r_offset)            = %014p\n", ((char*)mappingb + reloc->r_offset));
                                break;
                            }
                            case R_X86_64_GOTPCREL:
                            {
                                printf("\n\n\nR_X86_64_GOTPCREL            calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).))) \n");
                                break;
                            }
                            case R_X86_64_32:
                            {
                                printf("\n\n\nR_X86_64_32                  calculation: S + A (symbol value + r_addend)\n");
                                printf("reloc->r_offset = %14p\n", reloc->r_offset);
                                *((char*)mappingb + reloc->r_offset) = lookup_symbol_by_index(array, _elf_header, ELF64_R_SYM(reloc->r_info)) + reloc->r_addend+mappingb;
                                printf("((char*)mappingb + reloc->r_offset)            = %014p\n", ((char*)mappingb + reloc->r_offset));
                                break;
                            }
                            case R_X86_64_32S:
                            {
                                printf("\n\n\nR_X86_64_32S\n");
                                break;
                            }
                            case R_X86_64_16:
                            {
                                printf("\n\n\nR_X86_64_16\n");
                                break;
                            }
                            case R_X86_64_PC16:
                            {
                                printf("\n\n\nR_X86_64_PC16\n");
                                break;
                            }
                            case R_X86_64_8:
                            {
                                printf("\n\n\nR_X86_64_8\n");
                                break;
                            }
                            case R_X86_64_PC8:
                            {
                                printf("\n\n\nR_X86_64_PC8\n");
                                break;
                            }
                            case R_X86_64_DTPMOD64:
                            {
                                printf("\n\n\nR_X86_64_DTPMOD64\n");
                                break;
                            }
                            case R_X86_64_DTPOFF64:
                            {
                                printf("\n\n\nR_X86_64_DTPOFF64\n");
                                break;
                            }
                            case R_X86_64_TPOFF64:
                            {
                                printf("\n\n\nR_X86_64_TPOFF64\n");
                                break;
                            }
                            case R_X86_64_TLSGD:
                            {
                                printf("\n\n\nR_X86_64_TLSGD\n");
                                break;
                            }
                            case R_X86_64_TLSLD:
                            {
                                printf("\n\n\nR_X86_64_TLSLD\n");
                                break;
                            }
                            case R_X86_64_DTPOFF32:
                            {
                                printf("\n\n\nR_X86_64_DTPOFF32\n");
                                break;
                            }
                            case R_X86_64_GOTTPOFF:
                            {
                                printf("\n\n\nR_X86_64_GOTTPOFF\n");
                                break;
                            }
                            case R_X86_64_TPOFF32:
                            {
                                printf("\n\n\nR_X86_64_TPOFF32\n");
                                break;
                            }
                            case R_X86_64_PC64:
                            {
                                printf("\n\n\nR_X86_64_PC64\n");
                                break;
                            }
                            case R_X86_64_GOTOFF64:
                            {
                                printf("\n\n\nR_X86_64_GOTOFF64            calculation: S + A - GOT (symbol value + r_addend - address of global offset table)\n");
                                printf("reloc->r_offset = %14p\n", reloc->r_offset);
                                *((char*)mappingb + reloc->r_offset) = lookup_symbol_by_index(array, _elf_header, ELF64_R_SYM(reloc->r_info)) + reloc->r_addend+mappingb;
                                printf("((char*)mappingb + reloc->r_offset)            = %014p\n", ((char*)mappingb + reloc->r_offset));
                                break;
                            }
                            case R_X86_64_GOTPC32:
                            {
                                printf("\n\n\nR_X86_64_GOTPC32             calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_GOT64:
                            {
                                printf("\n\n\nR_X86_64_GOT64               calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_GOTPCREL64:
                            {
                                printf("\n\n\nR_X86_64_GOTPCREL64          calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_GOTPC64:
                            {
                                printf("\n\n\nR_X86_64_GOTPC64             calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_GOTPLT64:
                            {
                                printf("\n\n\nR_X86_64_GOTPLT64            calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_PLTOFF64:
                            {
                                printf("\n\n\nR_X86_64_PLTOFF64\n");
                                break;
                            }
                            case R_X86_64_SIZE32:
                            {
                                printf("\n\n\nR_X86_64_SIZE32\n");
                                break;
                            }
                            case R_X86_64_SIZE64:
                            {
                                printf("\n\n\nR_X86_64_SIZE64\n");
                                break;
                            }
                            case R_X86_64_GOTPC32_TLSDESC:
                            {
                                printf("\n\n\nR_X86_64_GOTPC32_TLSDESC     calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_TLSDESC_CALL:
                            {
                                printf("\n\n\nR_X86_64_TLSDESC_CALL\n");
                                break;
                            }
                            case R_X86_64_TLSDESC:
                            {
                                printf("\n\n\nR_X86_64_TLSDESC\n");
                                break;
                            }
                            case R_X86_64_IRELATIVE:
                            {
                                printf("\n\n\nR_X86_64_IRELATIVE\n");
                                break;
                            }
                            case R_X86_64_RELATIVE64:
                            {
                                printf("\n\n\nR_X86_64_RELATIVE64\n");
                                break;
                            }
                            case R_X86_64_GOTPCRELX:
                            {
                                printf("\n\n\nR_X86_64_GOTPCRELX           calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_REX_GOTPCRELX:
                            {
                                printf("\n\n\nR_X86_64_REX_GOTPCRELX       calculation: (_GOTPC: GOT + A - P (address of global offset table + r_addend - (P: This means the place (section offset or address) of the storage unit being relocated (computed using r_offset ).)))\n");
                                break;
                            }
                            case R_X86_64_NUM:
                            {
                                printf("\n\n\nR_X86_64_NUM\n");
                                break;
                            }
                            #endif
                            default:
                                printf("unknown type, got %d\n", reloc_type);
                                break;
                        }
                    }
                }
            }
//             nl();
            
            printf("Section Header\t \
_elf_header->e_shstrndx %014p (\
_elf_header->e_shnum = %d entries with a total of \
_elf_header->e_shentsize = %d (should match %d) bytes, offset is \
_elf_header->e_shoff = %014p)\n",\
            _elf_header->e_shstrndx,\
            _elf_header->e_shnum,\
            _elf_header->e_shentsize,\
            sizeof(Elf64_Shdr),\
            _elf_header->e_shoff,\
            (char *)array + _elf_header->e_shoff\
            );
            read_section_header_table_(array, _elf_header, &_elf_symbol_table);
            print_section_headers_(array, _elf_header, _elf_symbol_table);
            print_symbols(array, _elf_header, _elf_symbol_table);
        } else {
                /* Not ELF file */
                printf("ELFMAGIC not found\n");
                printf ("header = ");
                __print_quoted_string__(array, sizeof(_elf_header->e_ident), QUOTE_OMIT_LEADING_TRAILING_QUOTES, "print");
                printf("\n");
                printf("ELF Identifier\t %s (", _elf_header->e_ident);
                __print_quoted_string__(_elf_header->e_ident, sizeof(_elf_header->e_ident), QUOTE_FORCE_HEX|QUOTE_OMIT_LEADING_TRAILING_QUOTES, "print");
                printf(" )\n");
            return 0;
        }
//     printf("Exited\n");
    return 0;
}

int
__string_quote__(const char *instr, char *outstr, const unsigned int size, const unsigned int style)
{
    const unsigned char *ustr = (const unsigned char *) instr;
    char *s = outstr;
    unsigned int i;
    int usehex, usehexX, uselen, c;

    int xflag = 0;
    usehex = 0;
    usehexX = 0;
    uselen = 0;
    if ((style == 9998)) {
        usehexX = 1;
    } else if ((style == 9999)) {
        uselen = 1;
    } else if ((xflag > 1) || (style & QUOTE_FORCE_HEX)) {
        usehex = 1;
    } else if (xflag) {
        /* Check for presence of symbol which require
        to hex-quote the whole string. */
        for (i = 0; i < size; ++i) {
            c = ustr[i];
            /* Check for NUL-terminated string. */
            if (c == 0x100)
                break;

            /* Force hex unless c is printable or whitespace */
            if (c > 0x7e) {
                usehex = 1;
                break;
            }
            /* In ASCII isspace is only these chars: "\t\n\v\f\r".
            * They happen to have ASCII codes 9,10,11,12,13.
            */
            if (c < ' ' && (unsigned)(c - 9) >= 5) {
                usehex = 1;
                break;
            }
        }
    }

    if (!(style & QUOTE_OMIT_LEADING_TRAILING_QUOTES))
        *s++ = '\"';

    if (usehexX) {
        /* Hex-quote the whole string. */
        for (i = 0; i < size; ++i) {
            c = ustr[i];
            /* Check for NUL-terminated string. */
            if (c == 0x100)
                goto asciz_ended;
            // print hex in " 00 00" format instead of "\x00\x00" format
//             *s++ = '\\';
            *s++ = ' ';
            *s++ = "0123456789abcdef"[c >> 4];
            *s++ = "0123456789abcdef"[c & 0xf];
        }
    } else if (usehex) {
        /* Hex-quote the whole string. */
        for (i = 0; i < size; ++i) {
            c = ustr[i];
            /* Check for NUL-terminated string. */
            if (c == 0x100)
                goto asciz_ended;
            *s++ = '\\';
            *s++ = 'x';
            *s++ = "0123456789abcdef"[c >> 4];
            *s++ = "0123456789abcdef"[c & 0xf];
        }
    } else if (uselen) {
        /* Hex-quote the whole string. */
        for (i = 0; i < size; ++i) {
            c = ustr[i];
            /* Check for NUL-terminated string. */
            if (c == 0x100)
                goto asciz_ended;
            *s++ = '1';
        }
    } else {
        for (i = 0; i < size; ++i) {
            c = ustr[i];
            /* Check for NUL-terminated string. */
            if (c == 0x100)
                goto asciz_ended;
            if ((i == (size - 1)) &&
                (style & QUOTE_OMIT_TRAILING_0) && (c == '\0'))
                goto asciz_ended;
                int pass_one = 0;
                int pass_two = 0;
                int pass_three = 0;
                int pass_four = 0;
                if (c == '\f') {
                    *s++ = '\\';
                    *s++ = 'f';
                    pass_one = 1;
                    pass_three = 1;
                    pass_four= 1;
//                         if i wanted a string to be printf safe what characters would i need to replace or modify, for example "hi"ko-pl" would need to be "hi\"ko"'-'"pl"
//                         \x27 is '
//                     xargs -0 printf '%s'<<EOF
//                     "hi"ko-p'l"
//                     EOF
                }
                if (pass_one == 0) {
                    if (c == '%'/*FOR PRINTF*/) {
                        *s++ = '%';
                        *s++ = '%';
                        pass_two = 1;
                        pass_three = 1;
                        pass_four= 1;
                    } else {
                        pass_two = 1;
                    }
                }
                if (pass_two == 0) {
                    if (c == '\"') {
                        /*FOR PRINTF/SHELL*/
                        *s++ = '\\';
                        *s++ = '\"';
                        pass_three = 1;
                        pass_four= 1;
                    } else if (c == '\\') {
                        /*FOR PRINTF/SHELL*/
                        *s++ = '\\';
                        *s++ = '\\';
                        pass_three = 1;
                        pass_four= 1;
                    } else if (c == '`'/*FOR PRINTF*/|| c == '$'/*FOR BASH*/) {
//                             *s++ = '\\';
                        *s++ = c;
                        pass_three = 1;
                        pass_four= 1;
                    } else if (c == '\''/*FOR PRINTF*/) {
//                             *s++ = '\\';
//                             *s++ = 'x';
//                             *s++ = '2';
                        *s++ = c;
                        pass_three = 1;
                        pass_four= 1;
                    } else if (c == '!'/*FOR BASH*/ || c ==  '-'/*FOR PRINTF*/) {
//                             *s++ = '"';
//                             *s++ = '\'';
                        *s++ = c;
//                             *s++ = '\'';
//                             *s++ = '"';
                        pass_three = 1;
                        pass_four= 1;
                    } else if (c == '%'/*FOR PRINTF*/) {
                        *s++ = '%';
                        *s++ = '%';
                        *s++ = '%';
                        *s++ = '%';
                        pass_three = 1;
                        pass_four= 1;
                    }
                }
                if (pass_three == 0) {
                    if (c == '\n') {
                        *s++ = '\\';
                        *s++ = 'n';
                        pass_four = 1;
                    } else if (c == '\r') {
                        *s++ = '\\';
                        *s++ = 'r';
                        pass_four = 1;
                    } else if (c == '\t') {
                        *s++ = '\\';
                        *s++ = 't';
                        pass_four = 1;
                    } else if (c == '\v') {
                        *s++ = '\\';
                        *s++ = 'v';
                        pass_four = 1;
                    }
                }
                if (pass_four == 0) {
                    if (c >= ' ' && c <= 0x7e)
                        *s++ = c;
                    else {
                        /* Print \octal */
                        *s++ = '\\';
                        if (i + 1 < size
                            && ustr[i + 1] >= '0'
                            && ustr[i + 1] <= '9'
                        ) {
                            /* Print \ooo */
                            *s++ = '0' + (c >> 6);
                            *s++ = '0' + ((c >> 3) & 0x7);
                        } else {
                            /* Print \[[o]o]o */
                            if ((c >> 3) != 0) {
                                if ((c >> 6) != 0)
                                    *s++ = '0' + (c >> 6);
                                *s++ = '0' + ((c >> 3) & 0x7);
                            }
                        }
                        *s++ = '0' + (c & 0x7);
                    }
            }
        }
    }

    if (!(style & QUOTE_OMIT_LEADING_TRAILING_QUOTES))
        *s++ = '\"';
    *s = '\0';

    /* Return zero if we printed entire ASCIZ string (didn't truncate it) */
    if (style & QUOTE_0_TERMINATED && ustr[i] == '\0') {
        /* We didn't see NUL yet (otherwise we'd jump to 'asciz_ended')
        * but next char is NUL.
        */
        return 0;
    }

    return 1;

asciz_ended:
    if (!(style & QUOTE_OMIT_LEADING_TRAILING_QUOTES))
        *s++ = '\"';
    *s = '\0';
    /* Return zero: we printed entire ASCIZ string (didn't truncate it) */
    return 0;
}
#endif
